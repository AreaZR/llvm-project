; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -passes=float2int -S | FileCheck %s -check-prefixes=CHECK,NONE
; RUN: opt < %s -passes=float2int -S --data-layout="n64" | FileCheck %s -check-prefixes=CHECK,ONLY64
; RUN: opt < %s -passes=float2int -S --data-layout="n8:16:32:64"| FileCheck %s -check-prefixes=CHECK,MULTIPLE

define dso_local noundef i32 @pr71958() local_unnamed_addr {
; NONE-LABEL: @pr5058(
; NONE-NEXT:  entry:
; NONE-NEXT:    [[X:%.*]] = alloca i32, align 4
; NONE-NEXT:    call void @llvm.lifetime.start.p0(i64 4, ptr nonnull [[X]])
; NONE-NEXT:    store volatile i32 1, ptr [[X]], align 4
; NONE-NEXT:    [[X_0_X_0_X_0_:%.*]] = load volatile i32, ptr [[X]], align 4
; NONE-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[X_0_X_0_X_0_]], 0
; NONE-NEXT:    [[TMP0:%.*]] = zext i1 [[CMP]] to i32
; NONE-NEXT:    [[MUL1:%.*]] = mul i32 [[TMP0]], 255
; NONE-NEXT:    [[TMP1:%.*]] = trunc i32 [[MUL1]] to i8
; NONE-NEXT:    [[CONV2:%.*]] = zext i8 [[TMP1]] to i32
; NONE-NEXT:    call void @llvm.lifetime.end.p0(i64 4, ptr nonnull [[X]])
; NONE-NEXT:    ret i32 [[CONV2]]
;
; ONLY64-LABEL: @pr5058(
; ONLY64-NEXT:  entry:
; ONLY64-NEXT:    [[X:%.*]] = alloca i32, align 4
; ONLY64-NEXT:    call void @llvm.lifetime.start.p0(i64 4, ptr nonnull [[X]])
; ONLY64-NEXT:    store volatile i32 1, ptr [[X]], align 4
; ONLY64-NEXT:    [[X_0_X_0_X_0_:%.*]] = load volatile i32, ptr [[X]], align 4
; ONLY64-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[X_0_X_0_X_0_]], 0
; ONLY64-NEXT:    [[TMP0:%.*]] = zext i1 [[CMP]] to i64
; ONLY64-NEXT:    [[MUL1:%.*]] = mul i64 [[TMP0]], 255
; ONLY64-NEXT:    [[TMP1:%.*]] = trunc i64 [[MUL1]] to i8
; ONLY64-NEXT:    [[CONV2:%.*]] = zext i8 [[TMP1]] to i32
; ONLY64-NEXT:    call void @llvm.lifetime.end.p0(i64 4, ptr nonnull [[X]])
; ONLY64-NEXT:    ret i32 [[CONV2]]
;
; MULTIPLE-LABEL: @pr5058(
; MULTIPLE-NEXT:  entry:
; MULTIPLE-NEXT:    [[X:%.*]] = alloca i32, align 4
; MULTIPLE-NEXT:    call void @llvm.lifetime.start.p0(i64 4, ptr nonnull [[X]])
; MULTIPLE-NEXT:    store volatile i32 1, ptr [[X]], align 4
; MULTIPLE-NEXT:    [[X_0_X_0_X_0_:%.*]] = load volatile i32, ptr [[X]], align 4
; MULTIPLE-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[X_0_X_0_X_0_]], 0
; MULTIPLE-NEXT:    [[TMP0:%.*]] = zext i1 [[CMP]] to i8
; MULTIPLE-NEXT:    [[MUL1:%.*]] = mul i8 [[TMP0]], 127
; MULTIPLE-NEXT:    [[CONV2:%.*]] = zext i8 [[MUL1]] to i32
; MULTIPLE-NEXT:    call void @llvm.lifetime.end.p0(i64 4, ptr nonnull [[X]])
; MULTIPLE-NEXT:    ret i32 [[CONV2]]
;
entry:
  %x = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %x)
  store volatile i32 1, ptr %x, align 4
  %x.0.x.0.x.0. = load volatile i32, ptr %x, align 4
  %cmp = icmp sgt i32 %x.0.x.0.x.0., 0
  %conv = uitofp i1 %cmp to float
  %mul = fmul float %conv, 2.550000e+02
  %conv1 = fptoui float %mul to i8
  %conv2 = zext i8 %conv1 to i32
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %x)
  ret i32 %conv2
}