; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt < %s -passes=instcombine -S | FileCheck %s

@glob = global i32 0

declare ptr @llvm.stacksave()
declare void @llvm.stackrestore(ptr)

;; Test that llvm.stackrestore is removed when possible.
define ptr @test1(i32 %P) {
; CHECK-LABEL: define ptr @test1(
; CHECK-SAME: i32 [[P:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = zext i32 [[P]] to i64
; CHECK-NEXT:    [[A:%.*]] = alloca i32, i64 [[TMP1]], align 4
; CHECK-NEXT:    ret ptr [[A]]
;
  %tmp = call ptr @llvm.stacksave( )
  call void @llvm.stackrestore( ptr %tmp ) ;; not restoring anything
  %A = alloca i32, i32 %P
  ret ptr %A
}


define void @test2(ptr %X) {
; CHECK-LABEL: define void @test2(
; CHECK-SAME: ptr [[X:%.*]]) {
; CHECK-NEXT:    ret void
;
  call void @llvm.stackrestore( ptr %X )  ;; no allocas before return.
  ret void
}


define void @foo(i32 %size) nounwind  {
; CHECK-LABEL: define void @foo(
; CHECK-SAME: i32 [[SIZE:%.*]]) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP118124:%.*]] = icmp sgt i32 [[SIZE]], 0
; CHECK-NEXT:    br i1 [[TMP118124]], label %[[BB_PREHEADER:.*]], label %[[RETURN:.*]]
; CHECK:       [[BB_PREHEADER]]:
; CHECK-NEXT:    br label %[[BB:.*]]
; CHECK:       [[BB]]:
; CHECK-NEXT:    [[I_0_REG2MEM_0:%.*]] = phi i32 [ 0, %[[BB_PREHEADER]] ], [ [[INDVAR_NEXT:%.*]], %[[BB]] ]
; CHECK-NEXT:    [[TMP:%.*]] = call ptr @llvm.stacksave.p0()
; CHECK-NEXT:    [[TMP0:%.*]] = zext nneg i32 [[SIZE]] to i64
; CHECK-NEXT:    [[TMP23:%.*]] = alloca i8, i64 [[TMP0]], align 1
; CHECK-NEXT:    [[TMP1:%.*]] = zext nneg i32 [[SIZE]] to i64
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i8, ptr [[TMP23]], i64 [[TMP1]]
; CHECK-NEXT:    [[TMP27:%.*]] = getelementptr i8, ptr [[TMP2]], i64 -1
; CHECK-NEXT:    store i8 0, ptr [[TMP27]], align 1
; CHECK-NEXT:    [[TMP3:%.*]] = zext nneg i32 [[SIZE]] to i64
; CHECK-NEXT:    [[TMP52:%.*]] = alloca i8, i64 [[TMP3]], align 1
; CHECK-NEXT:    [[TMP4:%.*]] = zext nneg i32 [[SIZE]] to i64
; CHECK-NEXT:    [[TMP77:%.*]] = alloca i8, i64 [[TMP4]], align 1
; CHECK-NEXT:    [[TMP5:%.*]] = zext nneg i32 [[SIZE]] to i64
; CHECK-NEXT:    [[TMP102:%.*]] = alloca i8, i64 [[TMP5]], align 1
; CHECK-NEXT:    call void @bar(i32 [[I_0_REG2MEM_0]], ptr nonnull [[TMP23]], ptr nonnull [[TMP52]], ptr nonnull [[TMP77]], ptr nonnull [[TMP102]], i32 [[SIZE]]) #[[ATTR0]]
; CHECK-NEXT:    call void @llvm.stackrestore.p0(ptr [[TMP]])
; CHECK-NEXT:    [[INDVAR_NEXT]] = add i32 [[I_0_REG2MEM_0]], 1
; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp eq i32 [[INDVAR_NEXT]], [[SIZE]]
; CHECK-NEXT:    br i1 [[EXITCOND]], label %[[RETURN]], label %[[BB]]
; CHECK:       [[RETURN]]:
; CHECK-NEXT:    ret void
;
entry:
  %tmp118124 = icmp sgt i32 %size, 0		; <i1> [#uses=1]
  br i1 %tmp118124, label %bb.preheader, label %return

bb.preheader:		; preds = %entry
  %tmp25 = add i32 %size, -1		; <i32> [#uses=1]
  %tmp125 = icmp slt i32 %size, 1		; <i1> [#uses=1]
  %smax = select i1 %tmp125, i32 1, i32 %size		; <i32> [#uses=1]
  br label %bb

bb:		; preds = %bb, %bb.preheader
  %i.0.reg2mem.0 = phi i32 [ 0, %bb.preheader ], [ %indvar.next, %bb ]		; <i32> [#uses=2]
  %tmp = call ptr @llvm.stacksave( )		; <ptr> [#uses=1]
  %tmp23 = alloca i8, i32 %size		; <ptr> [#uses=2]
  %tmp27 = getelementptr i8, ptr %tmp23, i32 %tmp25		; <ptr> [#uses=1]
  store i8 0, ptr %tmp27, align 1
  %tmp28 = call ptr @llvm.stacksave( )		; <ptr> [#uses=1]
  %tmp52 = alloca i8, i32 %size		; <ptr> [#uses=1]
  %tmp53 = call ptr @llvm.stacksave( )		; <ptr> [#uses=1]
  %tmp77 = alloca i8, i32 %size		; <ptr> [#uses=1]
  %tmp78 = call ptr @llvm.stacksave( )		; <ptr> [#uses=1]
  %tmp102 = alloca i8, i32 %size		; <ptr> [#uses=1]
  call void @bar( i32 %i.0.reg2mem.0, ptr %tmp23, ptr %tmp52, ptr %tmp77, ptr %tmp102, i32 %size ) nounwind
  call void @llvm.stackrestore( ptr %tmp78 )
  call void @llvm.stackrestore( ptr %tmp53 )
  call void @llvm.stackrestore( ptr %tmp28 )
  call void @llvm.stackrestore( ptr %tmp )
  %indvar.next = add i32 %i.0.reg2mem.0, 1		; <i32> [#uses=2]
  %exitcond = icmp eq i32 %indvar.next, %smax		; <i1> [#uses=1]
  br i1 %exitcond, label %return, label %bb

return:		; preds = %bb, %entry
  ret void
}


declare void @bar(i32, ptr, ptr, ptr, ptr, i32)

declare void @inalloca_callee(ptr inalloca(i32))

define void @test3(i32 %c) {
; CHECK-LABEL: define void @test3(
; CHECK-SAME: i32 [[C:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[I:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ [[I1:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[SAVE1:%.*]] = call ptr @llvm.stacksave.p0()
; CHECK-NEXT:    [[ARGMEM:%.*]] = alloca inalloca i32, align 4
; CHECK-NEXT:    store i32 0, ptr [[ARGMEM]], align 4
; CHECK-NEXT:    call void @inalloca_callee(ptr nonnull inalloca(i32) [[ARGMEM]])
; CHECK-NEXT:    call void @llvm.stackrestore.p0(ptr [[SAVE1]])
; CHECK-NEXT:    store i32 0, ptr @glob, align 4
; CHECK-NEXT:    [[I1]] = add i32 [[I]], 1
; CHECK-NEXT:    [[DONE:%.*]] = icmp eq i32 [[I1]], [[C]]
; CHECK-NEXT:    br i1 [[DONE]], label %[[LOOP]], label %[[RETURN:.*]]
; CHECK:       [[RETURN]]:
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  %i = phi i32 [0, %entry], [%i1, %loop]
  %save1 = call ptr @llvm.stacksave()
  %argmem = alloca inalloca i32
  store i32 0, ptr %argmem
  call void @inalloca_callee(ptr inalloca(i32) %argmem)

  ; This restore cannot be deleted, the restore below does not make it dead.
  call void @llvm.stackrestore(ptr %save1)

  ; FIXME: We should be able to remove this save/restore pair, but we don't.
  %save2 = call ptr @llvm.stacksave()
  store i32 0, ptr @glob
  call void @llvm.stackrestore(ptr %save2)
  %i1 = add i32 1, %i
  %done = icmp eq i32 %i1, %c
  br i1 %done, label %loop, label %return

return:
  ret void
}


define i32 @test4(i32 %m, ptr %a, ptr %b) {
; CHECK-LABEL: define i32 @test4(
; CHECK-SAME: i32 [[M:%.*]], ptr [[A:%.*]], ptr [[B:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[FOR_BODY:.*]]
; CHECK:       [[FOR_BODY]]:
; CHECK-NEXT:    [[X_012:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ [[ADD2:%.*]], %[[FOR_BODY]] ]
; CHECK-NEXT:    [[I_011:%.*]] = phi i32 [ 0, %[[ENTRY]] ], [ [[INC:%.*]], %[[FOR_BODY]] ]
; CHECK-NEXT:    [[LOAD1:%.*]] = load i32, ptr [[A]], align 4
; CHECK-NEXT:    [[MUL1:%.*]] = mul nsw i32 [[LOAD1]], [[M]]
; CHECK-NEXT:    [[ADD1:%.*]] = add nsw i32 [[MUL1]], [[X_012]]
; CHECK-NEXT:    [[LOAD2:%.*]] = load i32, ptr [[B]], align 4
; CHECK-NEXT:    [[MUL2:%.*]] = mul nsw i32 [[LOAD2]], [[M]]
; CHECK-NEXT:    [[ADD2]] = add nsw i32 [[MUL2]], [[ADD1]]
; CHECK-NEXT:    [[INC]] = add nuw nsw i32 [[I_011]], 1
; CHECK-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i32 [[INC]], 100
; CHECK-NEXT:    br i1 [[EXITCOND_NOT]], label %[[FOR_COND_CLEANUP:.*]], label %[[FOR_BODY]]
; CHECK:       [[FOR_COND_CLEANUP]]:
; CHECK-NEXT:    ret i32 [[ADD2]]
;
entry:
  br label %for.body

for.body:
  %x.012 = phi i32 [ 0, %entry ], [ %add2, %for.body ]
  %i.011 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %0 = call ptr @llvm.stacksave()
  %load1 = load i32, ptr %a, align 4
  %mul1 = mul nsw i32 %load1, %m
  %add1 = add nsw i32 %mul1, %x.012
  call void @llvm.stackrestore(ptr %0)
  %load2 = load i32, ptr %b, align 4
  %mul2 = mul nsw i32 %load2, %m
  %add2 = add nsw i32 %mul2, %add1
  call void @llvm.stackrestore(ptr %0)
  %inc = add nuw nsw i32 %i.011, 1
  %exitcond.not = icmp eq i32 %inc, 100
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body

for.cond.cleanup:
  ret i32 %add2
}

