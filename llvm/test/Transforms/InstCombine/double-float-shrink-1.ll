; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt < %s -passes=instcombine -S -mtriple x86_64-unknown-linux-gnu | FileCheck %s --check-prefixes=CHECK,LINUX,ISC99
; RUN: opt < %s -passes=instcombine -S -mtriple x86_64-pc-win32          | FileCheck %s --check-prefixes=CHECK,ISC99
; RUN: opt < %s -passes=instcombine -S -mtriple x86_64-pc-windows-msvc16 | FileCheck %s --check-prefixes=CHECK,MS64,ISC89
; RUN: opt < %s -passes=instcombine -S -mtriple i386-pc-windows-msvc     | FileCheck %s --check-prefixes=CHECK,ISC99
; RUN: opt < %s -passes=instcombine -S -mtriple i686-pc-windows-msvc17   | FileCheck %s --check-prefixes=CHECK,MS32,ISC89

; Check for and against shrinkage when using the
; unsafe-fp-math function attribute on a math lib
; function. This optimization may be overridden by
; the -enable-double-float-shrink option.
; PR17850: http://llvm.org/bugs/show_bug.cgi?id=17850

define float @acos_test1(float %f)   {
; LINUX-LABEL: define float @acos_test1(
; LINUX-SAME: float [[F:%.*]]) {
; LINUX-NEXT:    [[ACOSF:%.*]] = call fast float @acosf(float [[F]])
; LINUX-NEXT:    ret float [[ACOSF]]
;
; MS64-LABEL: define float @acos_test1(
; MS64-SAME: float [[F:%.*]]) {
; MS64-NEXT:    [[ACOSF:%.*]] = call fast float @acosf(float [[F]])
; MS64-NEXT:    ret float [[ACOSF]]
;
; MS32-LABEL: define float @acos_test1(
; MS32-SAME: float [[F:%.*]]) {
; MS32-NEXT:    [[CONV:%.*]] = fpext float [[F]] to double
; MS32-NEXT:    [[CALL:%.*]] = call fast double @acos(double [[CONV]])
; MS32-NEXT:    [[CONV1:%.*]] = fptrunc double [[CALL]] to float
; MS32-NEXT:    ret float [[CONV1]]
;
  %conv = fpext float %f to double
  %call = call fast double @acos(double %conv)
  %conv1 = fptrunc double %call to float
  ret float %conv1
}

define double @acos_test2(float %f)   {
; CHECK-LABEL: define double @acos_test2(
; CHECK-SAME: float [[F:%.*]]) {
; CHECK-NEXT:    [[CONV:%.*]] = fpext float [[F]] to double
; CHECK-NEXT:    [[CALL:%.*]] = call fast double @acos(double [[CONV]])
; CHECK-NEXT:    ret double [[CALL]]
;
  %conv = fpext float %f to double
  %call = call fast double @acos(double %conv)
  ret double %call
}

define float @acosh_test1(float %f)   {
; LINUX-LABEL: define float @acosh_test1(
; LINUX-SAME: float [[F:%.*]]) {
; LINUX-NEXT:    [[ACOSHF:%.*]] = call fast float @acoshf(float [[F]])
; LINUX-NEXT:    ret float [[ACOSHF]]
;
; ISC99-LABEL: define float @acosh_test1(
; ISC99-SAME: float [[F:%.*]]) {
; ISC99-NEXT:    [[ACOSHF:%.*]] = call fast float @acoshf(float [[F]])
; ISC99-NEXT:    ret float [[ACOSHF]]
;
; MS64-LABEL: define float @acosh_test1(
; MS64-SAME: float [[F:%.*]]) {
; MS64-NEXT:    [[CONV:%.*]] = fpext float [[F]] to double
; MS64-NEXT:    [[CALL:%.*]] = call fast double @acosh(double [[CONV]])
; MS64-NEXT:    [[CONV1:%.*]] = fptrunc double [[CALL]] to float
; MS64-NEXT:    ret float [[CONV1]]
;
; MS32-LABEL: define float @acosh_test1(
; MS32-SAME: float [[F:%.*]]) {
; MS32-NEXT:    [[CONV:%.*]] = fpext float [[F]] to double
; MS32-NEXT:    [[CALL:%.*]] = call fast double @acosh(double [[CONV]])
; MS32-NEXT:    [[CONV1:%.*]] = fptrunc double [[CALL]] to float
; MS32-NEXT:    ret float [[CONV1]]
;
  %conv = fpext float %f to double
  %call = call fast double @acosh(double %conv)
  %conv1 = fptrunc double %call to float
  ret float %conv1
}

define double @acosh_test2(float %f)   {
; CHECK-LABEL: define double @acosh_test2(
; CHECK-SAME: float [[F:%.*]]) {
; CHECK-NEXT:    [[CONV:%.*]] = fpext float [[F]] to double
; CHECK-NEXT:    [[CALL:%.*]] = call fast double @acosh(double [[CONV]])
; CHECK-NEXT:    ret double [[CALL]]
;
  %conv = fpext float %f to double
  %call = call fast double @acosh(double %conv)
  ret double %call
}

define float @asin_test1(float %f)   {
; LINUX-LABEL: define float @asin_test1(
; LINUX-SAME: float [[F:%.*]]) {
; LINUX-NEXT:    [[ASINF:%.*]] = call fast float @asinf(float [[F]])
; LINUX-NEXT:    ret float [[ASINF]]
;
; MS64-LABEL: define float @asin_test1(
; MS64-SAME: float [[F:%.*]]) {
; MS64-NEXT:    [[ASINF:%.*]] = call fast float @asinf(float [[F]])
; MS64-NEXT:    ret float [[ASINF]]
;
; MS32-LABEL: define float @asin_test1(
; MS32-SAME: float [[F:%.*]]) {
; MS32-NEXT:    [[CONV:%.*]] = fpext float [[F]] to double
; MS32-NEXT:    [[CALL:%.*]] = call fast double @asin(double [[CONV]])
; MS32-NEXT:    [[CONV1:%.*]] = fptrunc double [[CALL]] to float
; MS32-NEXT:    ret float [[CONV1]]
;
  %conv = fpext float %f to double
  %call = call fast double @asin(double %conv)
  %conv1 = fptrunc double %call to float
  ret float %conv1
}

define double @asin_test2(float %f)   {
; CHECK-LABEL: define double @asin_test2(
; CHECK-SAME: float [[F:%.*]]) {
; CHECK-NEXT:    [[CONV:%.*]] = fpext float [[F]] to double
; CHECK-NEXT:    [[CALL:%.*]] = call fast double @asin(double [[CONV]])
; CHECK-NEXT:    ret double [[CALL]]
;
  %conv = fpext float %f to double
  %call = call fast double @asin(double %conv)
  ret double %call
}

define float @asinh_test1(float %f)   {
; LINUX-LABEL: define float @asinh_test1(
; LINUX-SAME: float [[F:%.*]]) {
; LINUX-NEXT:    [[ASINHF:%.*]] = call fast float @asinhf(float [[F]])
; LINUX-NEXT:    ret float [[ASINHF]]
;
; ISC99-LABEL: define float @asinh_test1(
; ISC99-SAME: float [[F:%.*]]) {
; ISC99-NEXT:    [[ASINHF:%.*]] = call fast float @asinhf(float [[F]])
; ISC99-NEXT:    ret float [[ASINHF]]
;
; MS64-LABEL: define float @asinh_test1(
; MS64-SAME: float [[F:%.*]]) {
; MS64-NEXT:    [[CONV:%.*]] = fpext float [[F]] to double
; MS64-NEXT:    [[CALL:%.*]] = call fast double @asinh(double [[CONV]])
; MS64-NEXT:    [[CONV1:%.*]] = fptrunc double [[CALL]] to float
; MS64-NEXT:    ret float [[CONV1]]
;
; MS32-LABEL: define float @asinh_test1(
; MS32-SAME: float [[F:%.*]]) {
; MS32-NEXT:    [[CONV:%.*]] = fpext float [[F]] to double
; MS32-NEXT:    [[CALL:%.*]] = call fast double @asinh(double [[CONV]])
; MS32-NEXT:    [[CONV1:%.*]] = fptrunc double [[CALL]] to float
; MS32-NEXT:    ret float [[CONV1]]
;
  %conv = fpext float %f to double
  %call = call fast double @asinh(double %conv)
  %conv1 = fptrunc double %call to float
  ret float %conv1
}

define double @asinh_test2(float %f)   {
; CHECK-LABEL: define double @asinh_test2(
; CHECK-SAME: float [[F:%.*]]) {
; CHECK-NEXT:    [[CONV:%.*]] = fpext float [[F]] to double
; CHECK-NEXT:    [[CALL:%.*]] = call fast double @asinh(double [[CONV]])
; CHECK-NEXT:    ret double [[CALL]]
;
  %conv = fpext float %f to double
  %call = call fast double @asinh(double %conv)
  ret double %call
}

define float @atan_test1(float %f)   {
; LINUX-LABEL: define float @atan_test1(
; LINUX-SAME: float [[F:%.*]]) {
; LINUX-NEXT:    [[ATANF:%.*]] = call fast float @atanf(float [[F]])
; LINUX-NEXT:    ret float [[ATANF]]
;
; MS64-LABEL: define float @atan_test1(
; MS64-SAME: float [[F:%.*]]) {
; MS64-NEXT:    [[ATANF:%.*]] = call fast float @atanf(float [[F]])
; MS64-NEXT:    ret float [[ATANF]]
;
; MS32-LABEL: define float @atan_test1(
; MS32-SAME: float [[F:%.*]]) {
; MS32-NEXT:    [[CONV:%.*]] = fpext float [[F]] to double
; MS32-NEXT:    [[CALL:%.*]] = call fast double @atan(double [[CONV]])
; MS32-NEXT:    [[CONV1:%.*]] = fptrunc double [[CALL]] to float
; MS32-NEXT:    ret float [[CONV1]]
;
  %conv = fpext float %f to double
  %call = call fast double @atan(double %conv)
  %conv1 = fptrunc double %call to float
  ret float %conv1
}

define double @atan_test2(float %f)   {
; CHECK-LABEL: define double @atan_test2(
; CHECK-SAME: float [[F:%.*]]) {
; CHECK-NEXT:    [[CONV:%.*]] = fpext float [[F]] to double
; CHECK-NEXT:    [[CALL:%.*]] = call fast double @atan(double [[CONV]])
; CHECK-NEXT:    ret double [[CALL]]
;
  %conv = fpext float %f to double
  %call = call fast double @atan(double %conv)
  ret double %call
}

define float @atanh_test1(float %f)   {
; LINUX-LABEL: define float @atanh_test1(
; LINUX-SAME: float [[F:%.*]]) {
; LINUX-NEXT:    [[ATANHF:%.*]] = call fast float @atanhf(float [[F]])
; LINUX-NEXT:    ret float [[ATANHF]]
;
; ISC99-LABEL: define float @atanh_test1(
; ISC99-SAME: float [[F:%.*]]) {
; ISC99-NEXT:    [[ATANHF:%.*]] = call fast float @atanhf(float [[F]])
; ISC99-NEXT:    ret float [[ATANHF]]
;
; MS64-LABEL: define float @atanh_test1(
; MS64-SAME: float [[F:%.*]]) {
; MS64-NEXT:    [[CONV:%.*]] = fpext float [[F]] to double
; MS64-NEXT:    [[CALL:%.*]] = call fast double @atanh(double [[CONV]])
; MS64-NEXT:    [[CONV1:%.*]] = fptrunc double [[CALL]] to float
; MS64-NEXT:    ret float [[CONV1]]
;
; MS32-LABEL: define float @atanh_test1(
; MS32-SAME: float [[F:%.*]]) {
; MS32-NEXT:    [[CONV:%.*]] = fpext float [[F]] to double
; MS32-NEXT:    [[CALL:%.*]] = call fast double @atanh(double [[CONV]])
; MS32-NEXT:    [[CONV1:%.*]] = fptrunc double [[CALL]] to float
; MS32-NEXT:    ret float [[CONV1]]
;
  %conv = fpext float %f to double
  %call = call fast double @atanh(double %conv)
  %conv1 = fptrunc double %call to float
  ret float %conv1
}

define double @atanh_test2(float %f)   {
; CHECK-LABEL: define double @atanh_test2(
; CHECK-SAME: float [[F:%.*]]) {
; CHECK-NEXT:    [[CONV:%.*]] = fpext float [[F]] to double
; CHECK-NEXT:    [[CALL:%.*]] = call fast double @atanh(double [[CONV]])
; CHECK-NEXT:    ret double [[CALL]]
;
  %conv = fpext float %f to double
  %call = call fast double @atanh(double %conv)
  ret double %call
}

define float @cbrt_test1(float %f)   {
; LINUX-LABEL: define float @cbrt_test1(
; LINUX-SAME: float [[F:%.*]]) {
; LINUX-NEXT:    [[CBRTF:%.*]] = call fast float @cbrtf(float [[F]])
; LINUX-NEXT:    ret float [[CBRTF]]
;
; ISC99-LABEL: define float @cbrt_test1(
; ISC99-SAME: float [[F:%.*]]) {
; ISC99-NEXT:    [[CBRTF:%.*]] = call fast float @cbrtf(float [[F]])
; ISC99-NEXT:    ret float [[CBRTF]]
;
; MS64-LABEL: define float @cbrt_test1(
; MS64-SAME: float [[F:%.*]]) {
; MS64-NEXT:    [[CONV:%.*]] = fpext float [[F]] to double
; MS64-NEXT:    [[CALL:%.*]] = call fast double @cbrt(double [[CONV]])
; MS64-NEXT:    [[CONV1:%.*]] = fptrunc double [[CALL]] to float
; MS64-NEXT:    ret float [[CONV1]]
;
; MS32-LABEL: define float @cbrt_test1(
; MS32-SAME: float [[F:%.*]]) {
; MS32-NEXT:    [[CONV:%.*]] = fpext float [[F]] to double
; MS32-NEXT:    [[CALL:%.*]] = call fast double @cbrt(double [[CONV]])
; MS32-NEXT:    [[CONV1:%.*]] = fptrunc double [[CALL]] to float
; MS32-NEXT:    ret float [[CONV1]]
;
  %conv = fpext float %f to double
  %call = call fast double @cbrt(double %conv)
  %conv1 = fptrunc double %call to float
  ret float %conv1
}

define double @cbrt_test2(float %f)   {
; CHECK-LABEL: define double @cbrt_test2(
; CHECK-SAME: float [[F:%.*]]) {
; CHECK-NEXT:    [[CONV:%.*]] = fpext float [[F]] to double
; CHECK-NEXT:    [[CALL:%.*]] = call fast double @cbrt(double [[CONV]])
; CHECK-NEXT:    ret double [[CALL]]
;
  %conv = fpext float %f to double
  %call = call fast  double @cbrt(double %conv)
  ret double %call
}

define float @exp_test1(float %f)   {
; LINUX-LABEL: define float @exp_test1(
; LINUX-SAME: float [[F:%.*]]) {
; LINUX-NEXT:    [[EXPF:%.*]] = call fast float @expf(float [[F]])
; LINUX-NEXT:    ret float [[EXPF]]
;
; MS64-LABEL: define float @exp_test1(
; MS64-SAME: float [[F:%.*]]) {
; MS64-NEXT:    [[EXPF:%.*]] = call fast float @expf(float [[F]])
; MS64-NEXT:    ret float [[EXPF]]
;
; MS32-LABEL: define float @exp_test1(
; MS32-SAME: float [[F:%.*]]) {
; MS32-NEXT:    [[CONV:%.*]] = fpext float [[F]] to double
; MS32-NEXT:    [[CALL:%.*]] = call fast double @exp(double [[CONV]])
; MS32-NEXT:    [[CONV1:%.*]] = fptrunc double [[CALL]] to float
; MS32-NEXT:    ret float [[CONV1]]
;
  %conv = fpext float %f to double
  %call = call fast double @exp(double %conv)
  %conv1 = fptrunc double %call to float
  ret float %conv1
}

define double @exp_test2(float %f)   {
; CHECK-LABEL: define double @exp_test2(
; CHECK-SAME: float [[F:%.*]]) {
; CHECK-NEXT:    [[CONV:%.*]] = fpext float [[F]] to double
; CHECK-NEXT:    [[CALL:%.*]] = call fast double @exp(double [[CONV]])
; CHECK-NEXT:    ret double [[CALL]]
;
  %conv = fpext float %f to double
  %call = call fast double @exp(double %conv)
  ret double %call
}

define float @expm1_test1(float %f)   {
; LINUX-LABEL: define float @expm1_test1(
; LINUX-SAME: float [[F:%.*]]) {
; LINUX-NEXT:    [[EXPM1F:%.*]] = call fast float @expm1f(float [[F]])
; LINUX-NEXT:    ret float [[EXPM1F]]
;
; ISC99-LABEL: define float @expm1_test1(
; ISC99-SAME: float [[F:%.*]]) {
; ISC99-NEXT:    [[EXPM1F:%.*]] = call fast float @expm1f(float [[F]])
; ISC99-NEXT:    ret float [[EXPM1F]]
;
; MS64-LABEL: define float @expm1_test1(
; MS64-SAME: float [[F:%.*]]) {
; MS64-NEXT:    [[CONV:%.*]] = fpext float [[F]] to double
; MS64-NEXT:    [[CALL:%.*]] = call fast double @expm1(double [[CONV]])
; MS64-NEXT:    [[CONV1:%.*]] = fptrunc double [[CALL]] to float
; MS64-NEXT:    ret float [[CONV1]]
;
; MS32-LABEL: define float @expm1_test1(
; MS32-SAME: float [[F:%.*]]) {
; MS32-NEXT:    [[CONV:%.*]] = fpext float [[F]] to double
; MS32-NEXT:    [[CALL:%.*]] = call fast double @expm1(double [[CONV]])
; MS32-NEXT:    [[CONV1:%.*]] = fptrunc double [[CALL]] to float
; MS32-NEXT:    ret float [[CONV1]]
;
  %conv = fpext float %f to double
  %call = call fast double @expm1(double %conv)
  %conv1 = fptrunc double %call to float
  ret float %conv1
}

define double @expm1_test2(float %f)   {
; CHECK-LABEL: define double @expm1_test2(
; CHECK-SAME: float [[F:%.*]]) {
; CHECK-NEXT:    [[CONV:%.*]] = fpext float [[F]] to double
; CHECK-NEXT:    [[CALL:%.*]] = call fast double @expm1(double [[CONV]])
; CHECK-NEXT:    ret double [[CALL]]
;
  %conv = fpext float %f to double
  %call = call fast double @expm1(double %conv)
  ret double %call
}

; exp10f() doesn't exist for this triple, so it doesn't shrink.

define float @exp10_test1(float %f)   {
; CHECK-LABEL: define float @exp10_test1(
; CHECK-SAME: float [[F:%.*]]) {
; CHECK-NEXT:    [[CONV:%.*]] = fpext float [[F]] to double
; CHECK-NEXT:    [[CALL:%.*]] = call fast double @exp10(double [[CONV]])
; CHECK-NEXT:    [[CONV1:%.*]] = fptrunc double [[CALL]] to float
; CHECK-NEXT:    ret float [[CONV1]]
;
  %conv = fpext float %f to double
  %call = call fast double @exp10(double %conv)
  %conv1 = fptrunc double %call to float
  ret float %conv1
}

define double @exp10_test2(float %f)   {
; CHECK-LABEL: define double @exp10_test2(
; CHECK-SAME: float [[F:%.*]]) {
; CHECK-NEXT:    [[CONV:%.*]] = fpext float [[F]] to double
; CHECK-NEXT:    [[CALL:%.*]] = call fast double @exp10(double [[CONV]])
; CHECK-NEXT:    ret double [[CALL]]
;
  %conv = fpext float %f to double
  %call = call fast double @exp10(double %conv)
  ret double %call
}

define float @log_test1(float %f)   {
; LINUX-LABEL: define float @log_test1(
; LINUX-SAME: float [[F:%.*]]) {
; LINUX-NEXT:    [[LOGF:%.*]] = call fast float @logf(float [[F]])
; LINUX-NEXT:    ret float [[LOGF]]
;
; MS64-LABEL: define float @log_test1(
; MS64-SAME: float [[F:%.*]]) {
; MS64-NEXT:    [[LOGF:%.*]] = call fast float @logf(float [[F]])
; MS64-NEXT:    ret float [[LOGF]]
;
; MS32-LABEL: define float @log_test1(
; MS32-SAME: float [[F:%.*]]) {
; MS32-NEXT:    [[CONV:%.*]] = fpext float [[F]] to double
; MS32-NEXT:    [[CALL:%.*]] = call fast double @log(double [[CONV]])
; MS32-NEXT:    [[CONV1:%.*]] = fptrunc double [[CALL]] to float
; MS32-NEXT:    ret float [[CONV1]]
;
  %conv = fpext float %f to double
  %call = call fast double @log(double %conv)
  %conv1 = fptrunc double %call to float
  ret float %conv1
}

define double @log_test2(float %f)   {
; CHECK-LABEL: define double @log_test2(
; CHECK-SAME: float [[F:%.*]]) {
; CHECK-NEXT:    [[CONV:%.*]] = fpext float [[F]] to double
; CHECK-NEXT:    [[CALL:%.*]] = call fast double @log(double [[CONV]])
; CHECK-NEXT:    ret double [[CALL]]
;
  %conv = fpext float %f to double
  %call = call fast double @log(double %conv)
  ret double %call
}

define float @log10_test1(float %f)   {
; LINUX-LABEL: define float @log10_test1(
; LINUX-SAME: float [[F:%.*]]) {
; LINUX-NEXT:    [[LOG10F:%.*]] = call fast float @log10f(float [[F]])
; LINUX-NEXT:    ret float [[LOG10F]]
;
; MS64-LABEL: define float @log10_test1(
; MS64-SAME: float [[F:%.*]]) {
; MS64-NEXT:    [[LOG10F:%.*]] = call fast float @log10f(float [[F]])
; MS64-NEXT:    ret float [[LOG10F]]
;
; MS32-LABEL: define float @log10_test1(
; MS32-SAME: float [[F:%.*]]) {
; MS32-NEXT:    [[CONV:%.*]] = fpext float [[F]] to double
; MS32-NEXT:    [[CALL:%.*]] = call fast double @log10(double [[CONV]])
; MS32-NEXT:    [[CONV1:%.*]] = fptrunc double [[CALL]] to float
; MS32-NEXT:    ret float [[CONV1]]
;
  %conv = fpext float %f to double
  %call = call fast double @log10(double %conv)
  %conv1 = fptrunc double %call to float
  ret float %conv1
}

define double @log10_test2(float %f) {
; CHECK-LABEL: define double @log10_test2(
; CHECK-SAME: float [[F:%.*]]) {
; CHECK-NEXT:    [[CONV:%.*]] = fpext float [[F]] to double
; CHECK-NEXT:    [[CALL:%.*]] = call fast double @log10(double [[CONV]])
; CHECK-NEXT:    ret double [[CALL]]
;
  %conv = fpext float %f to double
  %call = call fast double @log10(double %conv)
  ret double %call
}

define float @log1p_test1(float %f)   {
; LINUX-LABEL: define float @log1p_test1(
; LINUX-SAME: float [[F:%.*]]) {
; LINUX-NEXT:    [[LOG1PF:%.*]] = call fast float @log1pf(float [[F]])
; LINUX-NEXT:    ret float [[LOG1PF]]
;
; ISC99-LABEL: define float @log1p_test1(
; ISC99-SAME: float [[F:%.*]]) {
; ISC99-NEXT:    [[LOG1PF:%.*]] = call fast float @log1pf(float [[F]])
; ISC99-NEXT:    ret float [[LOG1PF]]
;
; MS64-LABEL: define float @log1p_test1(
; MS64-SAME: float [[F:%.*]]) {
; MS64-NEXT:    [[CONV:%.*]] = fpext float [[F]] to double
; MS64-NEXT:    [[CALL:%.*]] = call fast double @log1p(double [[CONV]])
; MS64-NEXT:    [[CONV1:%.*]] = fptrunc double [[CALL]] to float
; MS64-NEXT:    ret float [[CONV1]]
;
; MS32-LABEL: define float @log1p_test1(
; MS32-SAME: float [[F:%.*]]) {
; MS32-NEXT:    [[CONV:%.*]] = fpext float [[F]] to double
; MS32-NEXT:    [[CALL:%.*]] = call fast double @log1p(double [[CONV]])
; MS32-NEXT:    [[CONV1:%.*]] = fptrunc double [[CALL]] to float
; MS32-NEXT:    ret float [[CONV1]]
;
  %conv = fpext float %f to double
  %call = call fast double @log1p(double %conv)
  %conv1 = fptrunc double %call to float
  ret float %conv1
}

define double @log1p_test2(float %f)   {
; CHECK-LABEL: define double @log1p_test2(
; CHECK-SAME: float [[F:%.*]]) {
; CHECK-NEXT:    [[CONV:%.*]] = fpext float [[F]] to double
; CHECK-NEXT:    [[CALL:%.*]] = call fast double @log1p(double [[CONV]])
; CHECK-NEXT:    ret double [[CALL]]
;
  %conv = fpext float %f to double
  %call = call fast double @log1p(double %conv)
  ret double %call
}

define float @log2_test1(float %f)   {
; LINUX-LABEL: define float @log2_test1(
; LINUX-SAME: float [[F:%.*]]) {
; LINUX-NEXT:    [[LOG2F:%.*]] = call fast float @log2f(float [[F]])
; LINUX-NEXT:    ret float [[LOG2F]]
;
; ISC99-LABEL: define float @log2_test1(
; ISC99-SAME: float [[F:%.*]]) {
; ISC99-NEXT:    [[LOG2F:%.*]] = call fast float @log2f(float [[F]])
; ISC99-NEXT:    ret float [[LOG2F]]
;
; MS64-LABEL: define float @log2_test1(
; MS64-SAME: float [[F:%.*]]) {
; MS64-NEXT:    [[CONV:%.*]] = fpext float [[F]] to double
; MS64-NEXT:    [[CALL:%.*]] = call fast double @log2(double [[CONV]])
; MS64-NEXT:    [[CONV1:%.*]] = fptrunc double [[CALL]] to float
; MS64-NEXT:    ret float [[CONV1]]
;
; MS32-LABEL: define float @log2_test1(
; MS32-SAME: float [[F:%.*]]) {
; MS32-NEXT:    [[CONV:%.*]] = fpext float [[F]] to double
; MS32-NEXT:    [[CALL:%.*]] = call fast double @log2(double [[CONV]])
; MS32-NEXT:    [[CONV1:%.*]] = fptrunc double [[CALL]] to float
; MS32-NEXT:    ret float [[CONV1]]
;
  %conv = fpext float %f to double
  %call = call fast double @log2(double %conv)
  %conv1 = fptrunc double %call to float
  ret float %conv1
}

define double @log2_test2(float %f)   {
; CHECK-LABEL: define double @log2_test2(
; CHECK-SAME: float [[F:%.*]]) {
; CHECK-NEXT:    [[CONV:%.*]] = fpext float [[F]] to double
; CHECK-NEXT:    [[CALL:%.*]] = call fast double @log2(double [[CONV]])
; CHECK-NEXT:    ret double [[CALL]]
;
  %conv = fpext float %f to double
  %call = call fast double @log2(double %conv)
  ret double %call
}

define float @logb_test1(float %f)   {
; LINUX-LABEL: define float @logb_test1(
; LINUX-SAME: float [[F:%.*]]) {
; LINUX-NEXT:    [[LOGBF:%.*]] = call fast float @logbf(float [[F]])
; LINUX-NEXT:    ret float [[LOGBF]]
;
; ISC99-LABEL: define float @logb_test1(
; ISC99-SAME: float [[F:%.*]]) {
; ISC99-NEXT:    [[LOGBF:%.*]] = call fast float @logbf(float [[F]])
; ISC99-NEXT:    ret float [[LOGBF]]
;
; MS64-LABEL: define float @logb_test1(
; MS64-SAME: float [[F:%.*]]) {
; MS64-NEXT:    [[LOGBF:%.*]] = call fast float @_logbf(float [[F]])
; MS64-NEXT:    ret float [[LOGBF]]
;
; MS32-LABEL: define float @logb_test1(
; MS32-SAME: float [[F:%.*]]) {
; MS32-NEXT:    [[CONV:%.*]] = fpext float [[F]] to double
; MS32-NEXT:    [[CALL:%.*]] = call fast double @logb(double [[CONV]])
; MS32-NEXT:    [[CONV1:%.*]] = fptrunc double [[CALL]] to float
; MS32-NEXT:    ret float [[CONV1]]
;
  %conv = fpext float %f to double
  %call = call fast double @logb(double %conv)
  %conv1 = fptrunc double %call to float
  ret float %conv1
}

define double @logb_test2(float %f)   {
; CHECK-LABEL: define double @logb_test2(
; CHECK-SAME: float [[F:%.*]]) {
; CHECK-NEXT:    [[CONV:%.*]] = fpext float [[F]] to double
; CHECK-NEXT:    [[CALL:%.*]] = call fast double @logb(double [[CONV]])
; CHECK-NEXT:    ret double [[CALL]]
;
  %conv = fpext float %f to double
  %call = call fast double @logb(double %conv)
  ret double %call
}

define float @pow_test1(float %f, float %g)   {
; LINUX-LABEL: define float @pow_test1(
; LINUX-SAME: float [[F:%.*]], float [[G:%.*]]) {
; LINUX-NEXT:    [[POWF:%.*]] = call fast float @powf(float [[F]], float [[G]])
; LINUX-NEXT:    ret float [[POWF]]
;
; MS64-LABEL: define float @pow_test1(
; MS64-SAME: float [[F:%.*]], float [[G:%.*]]) {
; MS64-NEXT:    [[POWF:%.*]] = call fast float @powf(float [[F]], float [[G]])
; MS64-NEXT:    ret float [[POWF]]
;
; MS32-LABEL: define float @pow_test1(
; MS32-SAME: float [[F:%.*]], float [[G:%.*]]) {
; MS32-NEXT:    [[DF:%.*]] = fpext float [[F]] to double
; MS32-NEXT:    [[DG:%.*]] = fpext float [[G]] to double
; MS32-NEXT:    [[CALL:%.*]] = call fast double @pow(double [[DF]], double [[DG]])
; MS32-NEXT:    [[FR:%.*]] = fptrunc double [[CALL]] to float
; MS32-NEXT:    ret float [[FR]]
;
  %df = fpext float %f to double
  %dg = fpext float %g to double
  %call = call fast double @pow(double %df, double %dg)
  %fr = fptrunc double %call to float
  ret float %fr
}

define double @pow_test2(float %f, float %g) {
; CHECK-LABEL: define double @pow_test2(
; CHECK-SAME: float [[F:%.*]], float [[G:%.*]]) {
; CHECK-NEXT:    [[DF:%.*]] = fpext float [[F]] to double
; CHECK-NEXT:    [[DG:%.*]] = fpext float [[G]] to double
; CHECK-NEXT:    [[CALL:%.*]] = call fast double @pow(double [[DF]], double [[DG]])
; CHECK-NEXT:    ret double [[CALL]]
;
  %df = fpext float %f to double
  %dg = fpext float %g to double
  %call = call fast double @pow(double %df, double %dg)
  ret double %call
}

define float @sin_test1(float %f)   {
; LINUX-LABEL: define float @sin_test1(
; LINUX-SAME: float [[F:%.*]]) {
; LINUX-NEXT:    [[SINF:%.*]] = call fast float @sinf(float [[F]])
; LINUX-NEXT:    ret float [[SINF]]
;
; MS64-LABEL: define float @sin_test1(
; MS64-SAME: float [[F:%.*]]) {
; MS64-NEXT:    [[SINF:%.*]] = call fast float @sinf(float [[F]])
; MS64-NEXT:    ret float [[SINF]]
;
; MS32-LABEL: define float @sin_test1(
; MS32-SAME: float [[F:%.*]]) {
; MS32-NEXT:    [[CONV:%.*]] = fpext float [[F]] to double
; MS32-NEXT:    [[CALL:%.*]] = call fast double @sin(double [[CONV]])
; MS32-NEXT:    [[CONV1:%.*]] = fptrunc double [[CALL]] to float
; MS32-NEXT:    ret float [[CONV1]]
;
  %conv = fpext float %f to double
  %call = call fast double @sin(double %conv)
  %conv1 = fptrunc double %call to float
  ret float %conv1
}

define double @sin_test2(float %f) {
; CHECK-LABEL: define double @sin_test2(
; CHECK-SAME: float [[F:%.*]]) {
; CHECK-NEXT:    [[CONV:%.*]] = fpext float [[F]] to double
; CHECK-NEXT:    [[CALL:%.*]] = call fast double @sin(double [[CONV]])
; CHECK-NEXT:    ret double [[CALL]]
;
  %conv = fpext float %f to double
  %call = call fast double @sin(double %conv)
  ret double %call
}

define float @sqrt_test1(float %f) {
; LINUX-LABEL: define float @sqrt_test1(
; LINUX-SAME: float [[F:%.*]]) {
; LINUX-NEXT:    [[SQRTF:%.*]] = call float @sqrtf(float [[F]])
; LINUX-NEXT:    ret float [[SQRTF]]
;
; MS64-LABEL: define float @sqrt_test1(
; MS64-SAME: float [[F:%.*]]) {
; MS64-NEXT:    [[SQRTF:%.*]] = call float @sqrtf(float [[F]])
; MS64-NEXT:    ret float [[SQRTF]]
;
; MS32-LABEL: define float @sqrt_test1(
; MS32-SAME: float [[F:%.*]]) {
; MS32-NEXT:    [[CONV:%.*]] = fpext float [[F]] to double
; MS32-NEXT:    [[CALL:%.*]] = call double @sqrt(double [[CONV]])
; MS32-NEXT:    [[CONV1:%.*]] = fptrunc double [[CALL]] to float
; MS32-NEXT:    ret float [[CONV1]]
;
  %conv = fpext float %f to double
  %call = call double @sqrt(double %conv)
  %conv1 = fptrunc double %call to float
  ret float %conv1
}

define double @sqrt_test2(float %f) {
; CHECK-LABEL: define double @sqrt_test2(
; CHECK-SAME: float [[F:%.*]]) {
; CHECK-NEXT:    [[CONV:%.*]] = fpext float [[F]] to double
; CHECK-NEXT:    [[CALL:%.*]] = call double @sqrt(double [[CONV]])
; CHECK-NEXT:    ret double [[CALL]]
;
  %conv = fpext float %f to double
  %call = call double @sqrt(double %conv)
  ret double %call
}

define float @sqrt_int_test1(float %f) {
; LINUX-LABEL: define float @sqrt_int_test1(
; LINUX-SAME: float [[F:%.*]]) {
; LINUX-NEXT:    [[TMP1:%.*]] = call float @llvm.sqrt.f32(float [[F]])
; LINUX-NEXT:    ret float [[TMP1]]
;
; MS64-LABEL: define float @sqrt_int_test1(
; MS64-SAME: float [[F:%.*]]) {
; MS64-NEXT:    [[TMP1:%.*]] = call float @llvm.sqrt.f32(float [[F]])
; MS64-NEXT:    ret float [[TMP1]]
;
; MS32-LABEL: define float @sqrt_int_test1(
; MS32-SAME: float [[F:%.*]]) {
; MS32-NEXT:    [[CONV:%.*]] = fpext float [[F]] to double
; MS32-NEXT:    [[CALL:%.*]] = call double @llvm.sqrt.f64(double [[CONV]])
; MS32-NEXT:    [[CONV1:%.*]] = fptrunc double [[CALL]] to float
; MS32-NEXT:    ret float [[CONV1]]
;
  %conv = fpext float %f to double
  %call = call double @llvm.sqrt.f64(double %conv)
  %conv1 = fptrunc double %call to float
  ret float %conv1
}

define double @sqrt_int_test2(float %f) {
; CHECK-LABEL: define double @sqrt_int_test2(
; CHECK-SAME: float [[F:%.*]]) {
; CHECK-NEXT:    [[CONV:%.*]] = fpext float [[F]] to double
; CHECK-NEXT:    [[CALL:%.*]] = call double @llvm.sqrt.f64(double [[CONV]])
; CHECK-NEXT:    ret double [[CALL]]
;
  %conv = fpext float %f to double
  %call = call double @llvm.sqrt.f64(double %conv)
  ret double %call
}

define float @tan_test1(float %f) {
; LINUX-LABEL: define float @tan_test1(
; LINUX-SAME: float [[F:%.*]]) {
; LINUX-NEXT:    [[TANF:%.*]] = call fast float @tanf(float [[F]])
; LINUX-NEXT:    ret float [[TANF]]
;
; MS64-LABEL: define float @tan_test1(
; MS64-SAME: float [[F:%.*]]) {
; MS64-NEXT:    [[TANF:%.*]] = call fast float @tanf(float [[F]])
; MS64-NEXT:    ret float [[TANF]]
;
; MS32-LABEL: define float @tan_test1(
; MS32-SAME: float [[F:%.*]]) {
; MS32-NEXT:    [[CONV:%.*]] = fpext float [[F]] to double
; MS32-NEXT:    [[CALL:%.*]] = call fast double @tan(double [[CONV]])
; MS32-NEXT:    [[CONV1:%.*]] = fptrunc double [[CALL]] to float
; MS32-NEXT:    ret float [[CONV1]]
;
  %conv = fpext float %f to double
  %call = call fast double @tan(double %conv)
  %conv1 = fptrunc double %call to float
  ret float %conv1
}

define double @tan_test2(float %f) {
; CHECK-LABEL: define double @tan_test2(
; CHECK-SAME: float [[F:%.*]]) {
; CHECK-NEXT:    [[CONV:%.*]] = fpext float [[F]] to double
; CHECK-NEXT:    [[CALL:%.*]] = call fast double @tan(double [[CONV]])
; CHECK-NEXT:    ret double [[CALL]]
;
  %conv = fpext float %f to double
  %call = call fast double @tan(double %conv)
  ret double %call
}
define float @tanh_test1(float %f) {
; LINUX-LABEL: define float @tanh_test1(
; LINUX-SAME: float [[F:%.*]]) {
; LINUX-NEXT:    [[TANHF:%.*]] = call fast float @tanhf(float [[F]])
; LINUX-NEXT:    ret float [[TANHF]]
;
; MS64-LABEL: define float @tanh_test1(
; MS64-SAME: float [[F:%.*]]) {
; MS64-NEXT:    [[TANHF:%.*]] = call fast float @tanhf(float [[F]])
; MS64-NEXT:    ret float [[TANHF]]
;
; MS32-LABEL: define float @tanh_test1(
; MS32-SAME: float [[F:%.*]]) {
; MS32-NEXT:    [[CONV:%.*]] = fpext float [[F]] to double
; MS32-NEXT:    [[CALL:%.*]] = call fast double @tanh(double [[CONV]])
; MS32-NEXT:    [[CONV1:%.*]] = fptrunc double [[CALL]] to float
; MS32-NEXT:    ret float [[CONV1]]
;
  %conv = fpext float %f to double
  %call = call fast double @tanh(double %conv)
  %conv1 = fptrunc double %call to float
  ret float %conv1
}

define double @tanh_test2(float %f) {
; CHECK-LABEL: define double @tanh_test2(
; CHECK-SAME: float [[F:%.*]]) {
; CHECK-NEXT:    [[CONV:%.*]] = fpext float [[F]] to double
; CHECK-NEXT:    [[CALL:%.*]] = call fast double @tanh(double [[CONV]])
; CHECK-NEXT:    ret double [[CALL]]
;
  %conv = fpext float %f to double
  %call = call fast double @tanh(double %conv)
  ret double %call
}

; 'arcp' on an fmax() is meaningless. This test just proves that
; flags are propagated for shrunken *binary* double FP calls.
define float @max1(float %a, float %b) {
; LINUX-LABEL: define float @max1(
; LINUX-SAME: float [[A:%.*]], float [[B:%.*]]) {
; LINUX-NEXT:    [[FMAXF:%.*]] = call nsz arcp float @llvm.maxnum.f32(float [[A]], float [[B]])
; LINUX-NEXT:    ret float [[FMAXF]]
;
; ISC99-LABEL: define float @max1(
; ISC99-SAME: float [[A:%.*]], float [[B:%.*]]) {
; ISC99-NEXT:    [[FMAXF:%.*]] = call nsz arcp float @llvm.maxnum.f32(float [[A]], float [[B]])
; ISC99-NEXT:    ret float [[FMAXF]]
;
; MS64-LABEL: define float @max1(
; MS64-SAME: float [[A:%.*]], float [[B:%.*]]) {
; MS64-NEXT:    [[C:%.*]] = fpext float [[A]] to double
; MS64-NEXT:    [[D:%.*]] = fpext float [[B]] to double
; MS64-NEXT:    [[E:%.*]] = call arcp double @fmax(double [[C]], double [[D]])
; MS64-NEXT:    [[F:%.*]] = fptrunc double [[E]] to float
; MS64-NEXT:    ret float [[F]]
;
; MS32-LABEL: define float @max1(
; MS32-SAME: float [[A:%.*]], float [[B:%.*]]) {
; MS32-NEXT:    [[C:%.*]] = fpext float [[A]] to double
; MS32-NEXT:    [[D:%.*]] = fpext float [[B]] to double
; MS32-NEXT:    [[E:%.*]] = call arcp double @fmax(double [[C]], double [[D]])
; MS32-NEXT:    [[F:%.*]] = fptrunc double [[E]] to float
; MS32-NEXT:    ret float [[F]]
;
  %c = fpext float %a to double
  %d = fpext float %b to double
  %e = call arcp double @fmax(double %c, double %d)
  %f = fptrunc double %e to float
  ret float %f
}

; This is treated as libm 'fmin' - LLVM types do not necessarily
; correspond to 'C' types, so this is not required to be "fminl".

define float @fake_fmin(float %a, float %b) {
; LINUX-LABEL: define float @fake_fmin(
; LINUX-SAME: float [[A:%.*]], float [[B:%.*]]) {
; LINUX-NEXT:    [[E1:%.*]] = call nsz float @llvm.minnum.f32(float [[A]], float [[B]])
; LINUX-NEXT:    ret float [[E1]]
;
; ISC99-LABEL: define float @fake_fmin(
; ISC99-SAME: float [[A:%.*]], float [[B:%.*]]) {
; ISC99-NEXT:    [[E1:%.*]] = call nsz float @llvm.minnum.f32(float [[A]], float [[B]])
; ISC99-NEXT:    ret float [[E1]]
;
; MS64-LABEL: define float @fake_fmin(
; MS64-SAME: float [[A:%.*]], float [[B:%.*]]) {
; MS64-NEXT:    [[C:%.*]] = fpext float [[A]] to fp128
; MS64-NEXT:    [[D:%.*]] = fpext float [[B]] to fp128
; MS64-NEXT:    [[E:%.*]] = call fp128 @fmin(fp128 [[C]], fp128 [[D]])
; MS64-NEXT:    [[F:%.*]] = fptrunc fp128 [[E]] to float
; MS64-NEXT:    ret float [[F]]
;
; MS32-LABEL: define float @fake_fmin(
; MS32-SAME: float [[A:%.*]], float [[B:%.*]]) {
; MS32-NEXT:    [[C:%.*]] = fpext float [[A]] to fp128
; MS32-NEXT:    [[D:%.*]] = fpext float [[B]] to fp128
; MS32-NEXT:    [[E:%.*]] = call fp128 @fmin(fp128 [[C]], fp128 [[D]])
; MS32-NEXT:    [[F:%.*]] = fptrunc fp128 [[E]] to float
; MS32-NEXT:    ret float [[F]]
;

  %c = fpext float %a to fp128
  %d = fpext float %b to fp128
  %e = call fp128 @fmin(fp128 %c, fp128 %d)
  %f = fptrunc fp128 %e to float
  ret float %f
}

declare fp128 @fmin(fp128, fp128)

declare double @fmax(double, double)

declare double @tanh(double)
declare double @tan(double)

; sqrt is a special case: the shrinking optimization
; is valid even without unsafe-fp-math.
declare double @sqrt(double)
declare double @llvm.sqrt.f64(double)

declare double @sin(double)
declare double @pow(double, double)
declare double @log2(double)
declare double @log1p(double)
declare double @log10(double)
declare double @log(double)
declare double @logb(double)
declare double @exp10(double)
declare double @expm1(double)
declare double @exp(double)
declare double @cbrt(double)
declare double @atanh(double)
declare double @atan(double)
declare double @acos(double)
declare double @acosh(double)
declare double @asin(double)
declare double @asinh(double)

;; NOTE: These prefixes are unused and the list is autogenerated. Do not add tests below this line:
; ISC89: {{.*}}
