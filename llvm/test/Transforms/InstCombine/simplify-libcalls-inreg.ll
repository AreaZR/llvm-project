; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -passes=instcombine -S %s | FileCheck %s

; The intent of this test is to check that the declarations produces for
; libcalls retains the inreg parameter attribute.

target datalayout = "e-m:e-p:32:32-p270:32:32-p271:32:32-p272:64:64-f64:32:64-f80:32-n8:16:32-S128"
target triple = "i386-unknown-linux-gnu"

declare ptr @foo()
declare i32 @memcmp(ptr inreg nocapture noundef, ptr inreg nocapture noundef, i32 inreg noundef)
declare i32 @printf(ptr, ...)
declare double @exp2(double)
declare i32 @__sprintf_chk(ptr, i32, i32, ptr, ...)
@a = common global [60 x i8] zeroinitializer, align 1
@b = common global [60 x i8] zeroinitializer, align 1
@h = constant [2 x i8] c"h\00"


define i32 @baz(ptr inreg noundef %s2, i32 inreg noundef %n){
; CHECK-LABEL: define i32 @baz(
; CHECK-SAME: ptr inreg noundef [[S2:%.*]], i32 inreg noundef [[N:%.*]]) {
; CHECK-NEXT:    [[CALL:%.*]] = call ptr @foo()
; CHECK-NEXT:    [[BCMP:%.*]] = call i32 @bcmp(ptr [[CALL]], ptr [[S2]], i32 [[N]])
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[BCMP]], 0
; CHECK-NEXT:    [[CONV:%.*]] = zext i1 [[CMP]] to i32
; CHECK-NEXT:    ret i32 [[CONV]]
;
  %call = call ptr @foo()
  %call1 = call i32 @memcmp(ptr inreg noundef %call, ptr inreg noundef %s2, i32 inreg noundef %n)
  %cmp = icmp eq i32 %call1, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}


define void @test_fewer_params_than_num_register_parameters() {
; CHECK-LABEL: define void @test_fewer_params_than_num_register_parameters() {
; CHECK-NEXT:    [[PUTCHAR:%.*]] = call i32 @putchar(i32 104)
; CHECK-NEXT:    ret void
;
  call i32 (ptr, ...) @printf(ptr @h)
  ret void
}


define double @test_non_int_params(i16 signext %x) {
; CHECK-LABEL: define double @test_non_int_params(
; CHECK-SAME: i16 signext [[X:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = sext i16 [[X]] to i32
; CHECK-NEXT:    [[LDEXP:%.*]] = call double @ldexp(double 1.000000e+00, i32 [[TMP1]])
; CHECK-NEXT:    ret double [[LDEXP]]
;
  %conv = sitofp i16 %x to double
  %ret = call double @exp2(double %conv)
  ret double %ret
}

define i32 @test_variadic() {
; CHECK-LABEL: define i32 @test_variadic() {
; CHECK-NEXT:    [[SPRINTF:%.*]] = call i32 (ptr, ptr, ...) @sprintf(ptr nonnull dereferenceable(1) @a, ptr nonnull dereferenceable(1) @b)
; CHECK-NEXT:    ret i32 [[SPRINTF]]
;
  %ret = call i32 (ptr, i32, i32, ptr, ...) @__sprintf_chk(ptr @a, i32 0, i32 -1, ptr @b)
  ret i32 %ret
}

!llvm.module.flags = !{!0}
!0 = !{i32 1, !"NumRegisterParameters", i32 3}
