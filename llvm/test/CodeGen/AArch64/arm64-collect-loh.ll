; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 4
; RUN: llc -o - %s -mtriple=arm64-apple-ios -O2 | FileCheck %s
; RUN: llc -o - %s -mtriple=arm64_32-apple-watchos -O2 | FileCheck %s
; RUN: llc -o - %s -mtriple=arm64-linux-gnu -O2 | FileCheck %s --check-prefix=CHECK-ELF

; CHECK-ELF-NOT: .loh
; CHECK-ELF-NOT: AdrpAdrp
; CHECK-ELF-NOT: AdrpAdd
; CHECK-ELF-NOT: AdrpLdrGot

@a = internal unnamed_addr global i32 0, align 4
@b = external global i32

; Function Attrs: noinline nounwind ssp
define void @foo(i32 %t) {
; CHECK-LABEL: foo:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    adrp x8, _a@PAGE
; CHECK-NEXT:    ldr w9, [x8, _a@PAGEOFF]
; CHECK-NEXT:    add w9, w9, w0
; CHECK-NEXT:    str w9, [x8, _a@PAGEOFF]
; CHECK-NEXT:    ret
;
; CHECK-ELF-LABEL: foo:
; CHECK-ELF:       // %bb.0: // %entry
; CHECK-ELF-NEXT:    adrp x8, a
; CHECK-ELF-NEXT:    ldr w9, [x8, :lo12:a]
; CHECK-ELF-NEXT:    add w9, w9, w0
; CHECK-ELF-NEXT:    str w9, [x8, :lo12:a]
; CHECK-ELF-NEXT:    ret
entry:
  %tmp = load i32, i32* @a, align 4
  %add = add nsw i32 %tmp, %t
  store i32 %add, i32* @a, align 4
  ret void
}

; Function Attrs: nounwind ssp
; Testcase for <rdar://problem/15438605>, AdrpAdrp reuse is valid only when the first adrp
; dominates the second.
; The first adrp comes from the loading of 'a' and the second the loading of 'b'.
; 'a' is loaded in if.then, 'b' in if.end4, if.then does not dominates if.end4.
; CHECK-LABEL: _test
; CHECK: ret
; CHECK-NOT: .loh AdrpAdrp
define i32 @test(i32 %t) {
; CHECK-LABEL: test:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    stp x20, x19, [sp, #-32]! ; 16-byte Folded Spill
; CHECK-NEXT:    stp x29, x30, [sp, #16] ; 16-byte Folded Spill
; CHECK-NEXT:    .cfi_def_cfa_offset 32
; CHECK-NEXT:    .cfi_offset w30, -8
; CHECK-NEXT:    .cfi_offset w29, -16
; CHECK-NEXT:    .cfi_offset w19, -24
; CHECK-NEXT:    .cfi_offset w20, -32
; CHECK-NEXT:    mov w19, w0
; CHECK-NEXT:    cmp w0, #6
; CHECK-NEXT:    b.lt LBB1_3
; CHECK-NEXT:  ; %bb.1: ; %if.then
; CHECK-NEXT:    adrp x20, _a@PAGE
; CHECK-NEXT:    ldr w8, [x20, _a@PAGEOFF]
; CHECK-NEXT:    add w0, w8, w19
; CHECK-NEXT:    cmp w0, #13
; CHECK-NEXT:    b.lt LBB1_3
; CHECK-NEXT:  ; %bb.2: ; %if.then2
; CHECK-NEXT:    bl _foo
; CHECK-NEXT:    ldr w19, [x20, _a@PAGEOFF]
; CHECK-NEXT:  LBB1_3: ; %if.end4
; CHECK-NEXT:  Lloh0:
; CHECK-NEXT:    adrp x20, _b@GOTPAGE
; CHECK-NEXT:  Lloh1:
; CHECK-NEXT:    ldr x20, [x20, _b@GOTPAGEOFF]
; CHECK-NEXT:    ldr w8, [x20]
; CHECK-NEXT:    add w0, w8, w19
; CHECK-NEXT:    bl _foo
; CHECK-NEXT:    ldr w8, [x20]
; CHECK-NEXT:    ldp x29, x30, [sp, #16] ; 16-byte Folded Reload
; CHECK-NEXT:    add w0, w8, w19
; CHECK-NEXT:    ldp x20, x19, [sp], #32 ; 16-byte Folded Reload
; CHECK-NEXT:    ret
; CHECK-NEXT:    .loh AdrpLdrGot Lloh0, Lloh1
;
; CHECK-ELF-LABEL: test:
; CHECK-ELF:       // %bb.0: // %entry
; CHECK-ELF-NEXT:    str x30, [sp, #-32]! // 8-byte Folded Spill
; CHECK-ELF-NEXT:    stp x20, x19, [sp, #16] // 16-byte Folded Spill
; CHECK-ELF-NEXT:    .cfi_def_cfa_offset 32
; CHECK-ELF-NEXT:    .cfi_offset w19, -8
; CHECK-ELF-NEXT:    .cfi_offset w20, -16
; CHECK-ELF-NEXT:    .cfi_offset w30, -32
; CHECK-ELF-NEXT:    mov w19, w0
; CHECK-ELF-NEXT:    cmp w0, #6
; CHECK-ELF-NEXT:    b.lt .LBB1_3
; CHECK-ELF-NEXT:  // %bb.1: // %if.then
; CHECK-ELF-NEXT:    adrp x20, a
; CHECK-ELF-NEXT:    ldr w8, [x20, :lo12:a]
; CHECK-ELF-NEXT:    add w0, w8, w19
; CHECK-ELF-NEXT:    cmp w0, #13
; CHECK-ELF-NEXT:    b.lt .LBB1_3
; CHECK-ELF-NEXT:  // %bb.2: // %if.then2
; CHECK-ELF-NEXT:    bl foo
; CHECK-ELF-NEXT:    ldr w19, [x20, :lo12:a]
; CHECK-ELF-NEXT:  .LBB1_3: // %if.end4
; CHECK-ELF-NEXT:    adrp x20, :got:b
; CHECK-ELF-NEXT:    ldr x20, [x20, :got_lo12:b]
; CHECK-ELF-NEXT:    ldr w8, [x20]
; CHECK-ELF-NEXT:    add w0, w8, w19
; CHECK-ELF-NEXT:    bl foo
; CHECK-ELF-NEXT:    ldr w8, [x20]
; CHECK-ELF-NEXT:    add w0, w8, w19
; CHECK-ELF-NEXT:    ldp x20, x19, [sp, #16] // 16-byte Folded Reload
; CHECK-ELF-NEXT:    ldr x30, [sp], #32 // 8-byte Folded Reload
; CHECK-ELF-NEXT:    ret
entry:
  %cmp = icmp sgt i32 %t, 5
  br i1 %cmp, label %if.then, label %if.end4

if.then:                                          ; preds = %entry
  %tmp = load i32, i32* @a, align 4
  %add = add nsw i32 %tmp, %t
  %cmp1 = icmp sgt i32 %add, 12
  br i1 %cmp1, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.then
  tail call void @foo(i32 %add)
  %tmp1 = load i32, i32* @a, align 4
  br label %if.end4

if.end4:                                          ; preds = %if.then2, %if.then, %entry
  %t.addr.0 = phi i32 [ %tmp1, %if.then2 ], [ %t, %if.then ], [ %t, %entry ]
  %tmp2 = load i32, i32* @b, align 4
  %add5 = add nsw i32 %tmp2, %t.addr.0
  tail call void @foo(i32 %add5)
  %tmp3 = load i32, i32* @b, align 4
  %add6 = add nsw i32 %tmp3, %t.addr.0
  ret i32 %add6
}

@C = common global i32 0, align 4

; Check that we catch AdrpLdrGotLdr case when we have a simple chain:
; adrp -> ldrgot -> ldr.
; CHECK-LABEL: _getC
; CHECK: [[ADRP_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: adrp [[ADRP_REG:x[0-9]+]], _C@GOTPAGE
; CHECK-NEXT: [[LDRGOT_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: ldr {{[xw]}}[[LDRGOT_REG:[0-9]+]], [[[ADRP_REG]], _C@GOTPAGEOFF]
; CHECK-NEXT: [[LDR_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: ldr w0, [x[[LDRGOT_REG]]]
; CHECK-NEXT: ret
; CHECK: .loh AdrpLdrGotLdr [[ADRP_LABEL]], [[LDRGOT_LABEL]], [[LDR_LABEL]]
define i32 @getC() {
; CHECK-LABEL: getC:
; CHECK:       ; %bb.0:
; CHECK-NEXT:  Lloh2:
; CHECK-NEXT:    adrp x8, _C@GOTPAGE
; CHECK-NEXT:  Lloh3:
; CHECK-NEXT:    ldr x8, [x8, _C@GOTPAGEOFF]
; CHECK-NEXT:  Lloh4:
; CHECK-NEXT:    ldr w0, [x8]
; CHECK-NEXT:    ret
; CHECK-NEXT:    .loh AdrpLdrGotLdr Lloh2, Lloh3, Lloh4
;
; CHECK-ELF-LABEL: getC:
; CHECK-ELF:       // %bb.0:
; CHECK-ELF-NEXT:    adrp x8, :got:C
; CHECK-ELF-NEXT:    ldr x8, [x8, :got_lo12:C]
; CHECK-ELF-NEXT:    ldr w0, [x8]
; CHECK-ELF-NEXT:    ret
  %res = load i32, i32* @C, align 4
  ret i32 %res
}

; LDRSW supports loading from a literal.
; Make sure we emit AdrpLdrGotLdr for those.
; CHECK-LABEL: _getSExtC
; CHECK: [[ADRP_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: adrp [[ADRP_REG:x[0-9]+]], _C@GOTPAGE
; CHECK-NEXT: [[LDRGOT_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: ldr {{[xw]}}[[LDRGOT_REG:[0-9]+]], [[[ADRP_REG]], _C@GOTPAGEOFF]
; CHECK-NEXT: [[LDR_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: ldrsw x0, [x[[LDRGOT_REG]]]
; CHECK-NEXT: ret
; CHECK: .loh AdrpLdrGotLdr [[ADRP_LABEL]], [[LDRGOT_LABEL]], [[LDR_LABEL]]
define i64 @getSExtC() {
; CHECK-LABEL: getSExtC:
; CHECK:       ; %bb.0:
; CHECK-NEXT:  Lloh5:
; CHECK-NEXT:    adrp x8, _C@GOTPAGE
; CHECK-NEXT:  Lloh6:
; CHECK-NEXT:    ldr x8, [x8, _C@GOTPAGEOFF]
; CHECK-NEXT:  Lloh7:
; CHECK-NEXT:    ldrsw x0, [x8]
; CHECK-NEXT:    ret
; CHECK-NEXT:    .loh AdrpLdrGotLdr Lloh5, Lloh6, Lloh7
;
; CHECK-ELF-LABEL: getSExtC:
; CHECK-ELF:       // %bb.0:
; CHECK-ELF-NEXT:    adrp x8, :got:C
; CHECK-ELF-NEXT:    ldr x8, [x8, :got_lo12:C]
; CHECK-ELF-NEXT:    ldrsw x0, [x8]
; CHECK-ELF-NEXT:    ret
  %res = load i32, i32* @C, align 4
  %sextres = sext i32 %res to i64
  ret i64 %sextres
}

; It may not be safe to fold the literal in the load if the address is
; used several times.
; Make sure we emit AdrpLdrGot for those.
; CHECK-LABEL: _getSeveralC
; CHECK: [[ADRP_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: adrp [[ADRP_REG:x[0-9]+]], _C@GOTPAGE
; CHECK-NEXT: [[LDRGOT_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: ldr {{[xw]}}[[LDRGOT_REG:[0-9]+]], [[[ADRP_REG]], _C@GOTPAGEOFF]
; CHECK-NEXT: ldr [[LOAD:w[0-9]+]], [x[[LDRGOT_REG]]]
; CHECK-NEXT: add [[ADD:w[0-9]+]], [[LOAD]], w0
; CHECK-NEXT: str [[ADD]], [x[[LDRGOT_REG]]]
; CHECK-NEXT: ret
; CHECK: .loh AdrpLdrGot [[ADRP_LABEL]], [[LDRGOT_LABEL]]
define void @getSeveralC(i32 %t) {
; CHECK-LABEL: getSeveralC:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:  Lloh8:
; CHECK-NEXT:    adrp x8, _C@GOTPAGE
; CHECK-NEXT:  Lloh9:
; CHECK-NEXT:    ldr x8, [x8, _C@GOTPAGEOFF]
; CHECK-NEXT:    ldr w9, [x8]
; CHECK-NEXT:    add w9, w9, w0
; CHECK-NEXT:    str w9, [x8]
; CHECK-NEXT:    ret
; CHECK-NEXT:    .loh AdrpLdrGot Lloh8, Lloh9
;
; CHECK-ELF-LABEL: getSeveralC:
; CHECK-ELF:       // %bb.0: // %entry
; CHECK-ELF-NEXT:    adrp x8, :got:C
; CHECK-ELF-NEXT:    ldr x8, [x8, :got_lo12:C]
; CHECK-ELF-NEXT:    ldr w9, [x8]
; CHECK-ELF-NEXT:    add w9, w9, w0
; CHECK-ELF-NEXT:    str w9, [x8]
; CHECK-ELF-NEXT:    ret
entry:
  %tmp = load i32, i32* @C, align 4
  %add = add nsw i32 %tmp, %t
  store i32 %add, i32* @C, align 4
  ret void
}

; Make sure we catch that:
; adrp -> ldrgot -> str.
; CHECK-LABEL: _setC
; CHECK: [[ADRP_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: adrp [[ADRP_REG:x[0-9]+]], _C@GOTPAGE
; CHECK-NEXT: [[LDRGOT_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: ldr {{[xw]}}[[LDRGOT_REG:[0-9]+]], [[[ADRP_REG]], _C@GOTPAGEOFF]
; CHECK-NEXT: [[LDR_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: str w0, [x[[LDRGOT_REG]]]
; CHECK-NEXT: ret
; CHECK: .loh AdrpLdrGotStr [[ADRP_LABEL]], [[LDRGOT_LABEL]], [[LDR_LABEL]]
define void @setC(i32 %t) {
; CHECK-LABEL: setC:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:  Lloh10:
; CHECK-NEXT:    adrp x8, _C@GOTPAGE
; CHECK-NEXT:  Lloh11:
; CHECK-NEXT:    ldr x8, [x8, _C@GOTPAGEOFF]
; CHECK-NEXT:  Lloh12:
; CHECK-NEXT:    str w0, [x8]
; CHECK-NEXT:    ret
; CHECK-NEXT:    .loh AdrpLdrGotStr Lloh10, Lloh11, Lloh12
;
; CHECK-ELF-LABEL: setC:
; CHECK-ELF:       // %bb.0: // %entry
; CHECK-ELF-NEXT:    adrp x8, :got:C
; CHECK-ELF-NEXT:    ldr x8, [x8, :got_lo12:C]
; CHECK-ELF-NEXT:    str w0, [x8]
; CHECK-ELF-NEXT:    ret
entry:
  store i32 %t, i32* @C, align 4
  ret void
}

; Perform the same tests for internal global and a displacement
; in the addressing mode.
; Indeed we will get an ADD for those instead of LOADGot.
@InternalC = internal global i32 0, align 4

; Check that we catch AdrpAddLdr case when we have a simple chain:
; adrp -> add -> ldr.
; CHECK-LABEL: _getInternalCPlus4
; CHECK: [[ADRP_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: adrp [[ADRP_REG:x[0-9]+]], _InternalC@PAGE
; CHECK-NEXT: [[ADDGOT_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: add [[ADDGOT_REG:x[0-9]+]], [[ADRP_REG]], _InternalC@PAGEOFF
; CHECK-NEXT: [[LDR_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: ldr w0, [[[ADDGOT_REG]], #16]
; CHECK-NEXT: ret
; CHECK: .loh AdrpAddLdr [[ADRP_LABEL]], [[ADDGOT_LABEL]], [[LDR_LABEL]]
define i32 @getInternalCPlus4() {
; CHECK-LABEL: getInternalCPlus4:
; CHECK:       ; %bb.0:
; CHECK-NEXT:  Lloh13:
; CHECK-NEXT:    adrp x8, _InternalC@PAGE
; CHECK-NEXT:  Lloh14:
; CHECK-NEXT:    add x8, x8, _InternalC@PAGEOFF
; CHECK-NEXT:  Lloh15:
; CHECK-NEXT:    ldr w0, [x8, #16]
; CHECK-NEXT:    ret
; CHECK-NEXT:    .loh AdrpAddLdr Lloh13, Lloh14, Lloh15
;
; CHECK-ELF-LABEL: getInternalCPlus4:
; CHECK-ELF:       // %bb.0:
; CHECK-ELF-NEXT:    adrp x8, InternalC
; CHECK-ELF-NEXT:    add x8, x8, :lo12:InternalC
; CHECK-ELF-NEXT:    ldr w0, [x8, #16]
; CHECK-ELF-NEXT:    ret
  %addr = getelementptr inbounds i32, i32* @InternalC, i32 4
  %res = load i32, i32* %addr, align 4
  ret i32 %res
}

; LDRSW supports loading from a literal.
; Make sure we emit AdrpLdrGotLdr for those.
; CHECK-LABEL: _getSExtInternalCPlus4
; CHECK: [[ADRP_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: adrp [[ADRP_REG:x[0-9]+]], _InternalC@PAGE
; CHECK-NEXT: [[ADDGOT_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: add [[ADDGOT_REG:x[0-9]+]], [[ADRP_REG]], _InternalC@PAGEOFF
; CHECK-NEXT: [[LDR_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: ldrsw x0, [[[ADDGOT_REG]], #16]
; CHECK-NEXT: ret
; CHECK: .loh AdrpAddLdr [[ADRP_LABEL]], [[ADDGOT_LABEL]], [[LDR_LABEL]]
define i64 @getSExtInternalCPlus4() {
; CHECK-LABEL: getSExtInternalCPlus4:
; CHECK:       ; %bb.0:
; CHECK-NEXT:  Lloh16:
; CHECK-NEXT:    adrp x8, _InternalC@PAGE
; CHECK-NEXT:  Lloh17:
; CHECK-NEXT:    add x8, x8, _InternalC@PAGEOFF
; CHECK-NEXT:  Lloh18:
; CHECK-NEXT:    ldrsw x0, [x8, #16]
; CHECK-NEXT:    ret
; CHECK-NEXT:    .loh AdrpAddLdr Lloh16, Lloh17, Lloh18
;
; CHECK-ELF-LABEL: getSExtInternalCPlus4:
; CHECK-ELF:       // %bb.0:
; CHECK-ELF-NEXT:    adrp x8, InternalC
; CHECK-ELF-NEXT:    add x8, x8, :lo12:InternalC
; CHECK-ELF-NEXT:    ldrsw x0, [x8, #16]
; CHECK-ELF-NEXT:    ret
  %addr = getelementptr inbounds i32, i32* @InternalC, i32 4
  %res = load i32, i32* %addr, align 4
  %sextres = sext i32 %res to i64
  ret i64 %sextres
}

; It may not be safe to fold the literal in the load if the address is
; used several times.
; Make sure we emit AdrpAdd for those.
; CHECK-LABEL: _getSeveralInternalCPlus4
; CHECK: [[ADRP_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: adrp [[ADRP_REG:x[0-9]+]], _InternalC@PAGE
; CHECK-NEXT: [[ADDGOT_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: add [[ADDGOT_REG:x[0-9]+]], [[ADRP_REG]], _InternalC@PAGEOFF
; CHECK-NEXT: ldr [[LOAD:w[0-9]+]], [[[ADDGOT_REG]], #16]
; CHECK-NEXT: add [[ADD:w[0-9]+]], [[LOAD]], w0
; CHECK-NEXT: str [[ADD]], [[[ADDGOT_REG]], #16]
; CHECK-NEXT: ret
; CHECK: .loh AdrpAdd [[ADRP_LABEL]], [[ADDGOT_LABEL]]
define void @getSeveralInternalCPlus4(i32 %t) {
; CHECK-LABEL: getSeveralInternalCPlus4:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:  Lloh19:
; CHECK-NEXT:    adrp x8, _InternalC@PAGE
; CHECK-NEXT:  Lloh20:
; CHECK-NEXT:    add x8, x8, _InternalC@PAGEOFF
; CHECK-NEXT:    ldr w9, [x8, #16]
; CHECK-NEXT:    add w9, w9, w0
; CHECK-NEXT:    str w9, [x8, #16]
; CHECK-NEXT:    ret
; CHECK-NEXT:    .loh AdrpAdd Lloh19, Lloh20
;
; CHECK-ELF-LABEL: getSeveralInternalCPlus4:
; CHECK-ELF:       // %bb.0: // %entry
; CHECK-ELF-NEXT:    adrp x8, InternalC
; CHECK-ELF-NEXT:    add x8, x8, :lo12:InternalC
; CHECK-ELF-NEXT:    ldr w9, [x8, #16]
; CHECK-ELF-NEXT:    add w9, w9, w0
; CHECK-ELF-NEXT:    str w9, [x8, #16]
; CHECK-ELF-NEXT:    ret
entry:
  %addr = getelementptr inbounds i32, i32* @InternalC, i32 4
  %tmp = load i32, i32* %addr, align 4
  %add = add nsw i32 %tmp, %t
  store i32 %add, i32* %addr, align 4
  ret void
}

; Make sure we catch that:
; adrp -> add -> str.
; CHECK-LABEL: _setInternalCPlus4
; CHECK: [[ADRP_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: adrp [[ADRP_REG:x[0-9]+]], _InternalC@PAGE
; CHECK-NEXT: [[ADDGOT_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: add [[ADDGOT_REG:x[0-9]+]], [[ADRP_REG]], _InternalC@PAGEOFF
; CHECK-NEXT: [[LDR_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: str w0, [[[ADDGOT_REG]], #16]
; CHECK-NEXT: ret
; CHECK: .loh AdrpAddStr [[ADRP_LABEL]], [[ADDGOT_LABEL]], [[LDR_LABEL]]
define void @setInternalCPlus4(i32 %t) {
; CHECK-LABEL: setInternalCPlus4:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:  Lloh21:
; CHECK-NEXT:    adrp x8, _InternalC@PAGE
; CHECK-NEXT:  Lloh22:
; CHECK-NEXT:    add x8, x8, _InternalC@PAGEOFF
; CHECK-NEXT:  Lloh23:
; CHECK-NEXT:    str w0, [x8, #16]
; CHECK-NEXT:    ret
; CHECK-NEXT:    .loh AdrpAddStr Lloh21, Lloh22, Lloh23
;
; CHECK-ELF-LABEL: setInternalCPlus4:
; CHECK-ELF:       // %bb.0: // %entry
; CHECK-ELF-NEXT:    adrp x8, InternalC
; CHECK-ELF-NEXT:    add x8, x8, :lo12:InternalC
; CHECK-ELF-NEXT:    str w0, [x8, #16]
; CHECK-ELF-NEXT:    ret
entry:
  %addr = getelementptr inbounds i32, i32* @InternalC, i32 4
  store i32 %t, i32* %addr, align 4
  ret void
}

; Check that we catch AdrpAddLdr case when we have a simple chain:
; adrp -> ldr.
; CHECK-LABEL: _getInternalC
; CHECK: [[ADRP_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: adrp [[ADRP_REG:x[0-9]+]], _InternalC@PAGE
; CHECK-NEXT: [[LDR_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: ldr w0, [[[ADRP_REG]], _InternalC@PAGEOFF]
; CHECK-NEXT: ret
; CHECK: .loh AdrpLdr [[ADRP_LABEL]], [[LDR_LABEL]]
define i32 @getInternalC() {
; CHECK-LABEL: getInternalC:
; CHECK:       ; %bb.0:
; CHECK-NEXT:  Lloh24:
; CHECK-NEXT:    adrp x8, _InternalC@PAGE
; CHECK-NEXT:  Lloh25:
; CHECK-NEXT:    ldr w0, [x8, _InternalC@PAGEOFF]
; CHECK-NEXT:    ret
; CHECK-NEXT:    .loh AdrpLdr Lloh24, Lloh25
;
; CHECK-ELF-LABEL: getInternalC:
; CHECK-ELF:       // %bb.0:
; CHECK-ELF-NEXT:    adrp x8, InternalC
; CHECK-ELF-NEXT:    ldr w0, [x8, :lo12:InternalC]
; CHECK-ELF-NEXT:    ret
  %res = load i32, i32* @InternalC, align 4
  ret i32 %res
}

; LDRSW supports loading from a literal.
; Make sure we emit AdrpLdrGotLdr for those.
; CHECK-LABEL: _getSExtInternalC
; CHECK: [[ADRP_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: adrp [[ADRP_REG:x[0-9]+]], _InternalC@PAGE
; CHECK-NEXT: [[LDR_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: ldrsw x0, [[[ADRP_REG]], _InternalC@PAGEOFF]
; CHECK-NEXT: ret
; CHECK: .loh AdrpLdr [[ADRP_LABEL]], [[LDR_LABEL]]
define i64 @getSExtInternalC() {
; CHECK-LABEL: getSExtInternalC:
; CHECK:       ; %bb.0:
; CHECK-NEXT:  Lloh26:
; CHECK-NEXT:    adrp x8, _InternalC@PAGE
; CHECK-NEXT:  Lloh27:
; CHECK-NEXT:    ldrsw x0, [x8, _InternalC@PAGEOFF]
; CHECK-NEXT:    ret
; CHECK-NEXT:    .loh AdrpLdr Lloh26, Lloh27
;
; CHECK-ELF-LABEL: getSExtInternalC:
; CHECK-ELF:       // %bb.0:
; CHECK-ELF-NEXT:    adrp x8, InternalC
; CHECK-ELF-NEXT:    ldrsw x0, [x8, :lo12:InternalC]
; CHECK-ELF-NEXT:    ret
  %res = load i32, i32* @InternalC, align 4
  %sextres = sext i32 %res to i64
  ret i64 %sextres
}

; It may not be safe to fold the literal in the load if the address is
; used several times.
; Make sure we do not catch anything here. We have a adrp alone,
; there is not much we can do about it.
; CHECK-LABEL: _getSeveralInternalC
; CHECK: adrp [[ADRP_REG:x[0-9]+]], _InternalC@PAGE
; CHECK-NEXT: ldr [[LOAD:w[0-9]+]], [[[ADRP_REG]], _InternalC@PAGEOFF]
; CHECK-NEXT: add [[ADD:w[0-9]+]], [[LOAD]], w0
; CHECK-NEXT: str [[ADD]], [[[ADRP_REG]], _InternalC@PAGEOFF]
; CHECK-NEXT: ret
define void @getSeveralInternalC(i32 %t) {
; CHECK-LABEL: getSeveralInternalC:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    adrp x8, _InternalC@PAGE
; CHECK-NEXT:    ldr w9, [x8, _InternalC@PAGEOFF]
; CHECK-NEXT:    add w9, w9, w0
; CHECK-NEXT:    str w9, [x8, _InternalC@PAGEOFF]
; CHECK-NEXT:    ret
;
; CHECK-ELF-LABEL: getSeveralInternalC:
; CHECK-ELF:       // %bb.0: // %entry
; CHECK-ELF-NEXT:    adrp x8, InternalC
; CHECK-ELF-NEXT:    ldr w9, [x8, :lo12:InternalC]
; CHECK-ELF-NEXT:    add w9, w9, w0
; CHECK-ELF-NEXT:    str w9, [x8, :lo12:InternalC]
; CHECK-ELF-NEXT:    ret
entry:
  %tmp = load i32, i32* @InternalC, align 4
  %add = add nsw i32 %tmp, %t
  store i32 %add, i32* @InternalC, align 4
  ret void
}

; Make sure we do not catch anything when:
; adrp -> str.
; We cannot fold anything in the str at this point.
; Indeed, strs do not support litterals.
; CHECK-LABEL: _setInternalC
; CHECK: adrp [[ADRP_REG:x[0-9]+]], _InternalC@PAGE
; CHECK-NEXT: str w0, [[[ADRP_REG]], _InternalC@PAGEOFF]
; CHECK-NEXT: ret
define void @setInternalC(i32 %t) {
; CHECK-LABEL: setInternalC:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    adrp x8, _InternalC@PAGE
; CHECK-NEXT:    str w0, [x8, _InternalC@PAGEOFF]
; CHECK-NEXT:    ret
;
; CHECK-ELF-LABEL: setInternalC:
; CHECK-ELF:       // %bb.0: // %entry
; CHECK-ELF-NEXT:    adrp x8, InternalC
; CHECK-ELF-NEXT:    str w0, [x8, :lo12:InternalC]
; CHECK-ELF-NEXT:    ret
entry:
  store i32 %t, i32* @InternalC, align 4
  ret void
}

; Now check other variant of loads/stores.

@D = common global i8 0, align 4

; LDRB does not support loading from a literal.
; Make sure we emit AdrpLdrGot and not AdrpLdrGotLdr for those.
; CHECK-LABEL: _getD
; CHECK: [[ADRP_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: adrp [[ADRP_REG:x[0-9]+]], _D@GOTPAGE
; CHECK-NEXT: [[LDRGOT_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: ldr {{[xw]}}[[LDRGOT_REG:[0-9]+]], [[[ADRP_REG]], _D@GOTPAGEOFF]
; CHECK-NEXT: ldrb w0, [x[[LDRGOT_REG]]]
; CHECK-NEXT: ret
; CHECK: .loh AdrpLdrGot [[ADRP_LABEL]], [[LDRGOT_LABEL]]
define i8 @getD() {
; CHECK-LABEL: getD:
; CHECK:       ; %bb.0:
; CHECK-NEXT:  Lloh28:
; CHECK-NEXT:    adrp x8, _D@GOTPAGE
; CHECK-NEXT:  Lloh29:
; CHECK-NEXT:    ldr x8, [x8, _D@GOTPAGEOFF]
; CHECK-NEXT:    ldrb w0, [x8]
; CHECK-NEXT:    ret
; CHECK-NEXT:    .loh AdrpLdrGot Lloh28, Lloh29
;
; CHECK-ELF-LABEL: getD:
; CHECK-ELF:       // %bb.0:
; CHECK-ELF-NEXT:    adrp x8, :got:D
; CHECK-ELF-NEXT:    ldr x8, [x8, :got_lo12:D]
; CHECK-ELF-NEXT:    ldrb w0, [x8]
; CHECK-ELF-NEXT:    ret
  %res = load i8, i8* @D, align 4
  ret i8 %res
}

; CHECK-LABEL: _setD
; CHECK: [[ADRP_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: adrp [[ADRP_REG:x[0-9]+]], _D@GOTPAGE
; CHECK-NEXT: [[LDRGOT_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: ldr {{[xw]}}[[LDRGOT_REG:[0-9]+]], [[[ADRP_REG]], _D@GOTPAGEOFF]
; CHECK-NEXT: [[STR_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: strb w0, [x[[LDRGOT_REG]]]
; CHECK-NEXT: ret
; CHECK: .loh AdrpLdrGotStr [[ADRP_LABEL]], [[LDRGOT_LABEL]], [[STR_LABEL]]
define void @setD(i8 %t) {
; CHECK-LABEL: setD:
; CHECK:       ; %bb.0:
; CHECK-NEXT:  Lloh30:
; CHECK-NEXT:    adrp x8, _D@GOTPAGE
; CHECK-NEXT:  Lloh31:
; CHECK-NEXT:    ldr x8, [x8, _D@GOTPAGEOFF]
; CHECK-NEXT:  Lloh32:
; CHECK-NEXT:    strb w0, [x8]
; CHECK-NEXT:    ret
; CHECK-NEXT:    .loh AdrpLdrGotStr Lloh30, Lloh31, Lloh32
;
; CHECK-ELF-LABEL: setD:
; CHECK-ELF:       // %bb.0:
; CHECK-ELF-NEXT:    adrp x8, :got:D
; CHECK-ELF-NEXT:    ldr x8, [x8, :got_lo12:D]
; CHECK-ELF-NEXT:    strb w0, [x8]
; CHECK-ELF-NEXT:    ret
  store i8 %t, i8* @D, align 4
  ret void
}

; LDRSB supports loading from a literal.
; Make sure we emit AdrpLdrGotLdr for those.
; CHECK-LABEL: _getSExtD
; CHECK: [[ADRP_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: adrp [[ADRP_REG:x[0-9]+]], _D@GOTPAGE
; CHECK-NEXT: [[LDRGOT_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: ldr {{[xw]}}[[LDRGOT_REG:[0-9]+]], [[[ADRP_REG]], _D@GOTPAGEOFF]
; CHECK-NEXT: [[LDR_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: ldrsb w0, [x[[LDRGOT_REG]]]
; CHECK-NEXT: ret
; CHECK: .loh AdrpLdrGotLdr [[ADRP_LABEL]], [[LDRGOT_LABEL]], [[LDR_LABEL]]
define i32 @getSExtD() {
; CHECK-LABEL: getSExtD:
; CHECK:       ; %bb.0:
; CHECK-NEXT:  Lloh33:
; CHECK-NEXT:    adrp x8, _D@GOTPAGE
; CHECK-NEXT:  Lloh34:
; CHECK-NEXT:    ldr x8, [x8, _D@GOTPAGEOFF]
; CHECK-NEXT:  Lloh35:
; CHECK-NEXT:    ldrsb w0, [x8]
; CHECK-NEXT:    ret
; CHECK-NEXT:    .loh AdrpLdrGotLdr Lloh33, Lloh34, Lloh35
;
; CHECK-ELF-LABEL: getSExtD:
; CHECK-ELF:       // %bb.0:
; CHECK-ELF-NEXT:    adrp x8, :got:D
; CHECK-ELF-NEXT:    ldr x8, [x8, :got_lo12:D]
; CHECK-ELF-NEXT:    ldrsb w0, [x8]
; CHECK-ELF-NEXT:    ret
  %res = load i8, i8* @D, align 4
  %sextres = sext i8 %res to i32
  ret i32 %sextres
}

; LDRSB supports loading from a literal.
; Make sure we emit AdrpLdrGotLdr for those.
; CHECK-LABEL: _getSExt64D
; CHECK: [[ADRP_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: adrp [[ADRP_REG:x[0-9]+]], _D@GOTPAGE
; CHECK-NEXT: [[LDRGOT_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: ldr {{[xw]}}[[LDRGOT_REG:[0-9]+]], [[[ADRP_REG]], _D@GOTPAGEOFF]
; CHECK-NEXT: [[LDR_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: ldrsb x0, [x[[LDRGOT_REG]]]
; CHECK-NEXT: ret
; CHECK: .loh AdrpLdrGotLdr [[ADRP_LABEL]], [[LDRGOT_LABEL]], [[LDR_LABEL]]
define i64 @getSExt64D() {
; CHECK-LABEL: getSExt64D:
; CHECK:       ; %bb.0:
; CHECK-NEXT:  Lloh36:
; CHECK-NEXT:    adrp x8, _D@GOTPAGE
; CHECK-NEXT:  Lloh37:
; CHECK-NEXT:    ldr x8, [x8, _D@GOTPAGEOFF]
; CHECK-NEXT:  Lloh38:
; CHECK-NEXT:    ldrsb x0, [x8]
; CHECK-NEXT:    ret
; CHECK-NEXT:    .loh AdrpLdrGotLdr Lloh36, Lloh37, Lloh38
;
; CHECK-ELF-LABEL: getSExt64D:
; CHECK-ELF:       // %bb.0:
; CHECK-ELF-NEXT:    adrp x8, :got:D
; CHECK-ELF-NEXT:    ldr x8, [x8, :got_lo12:D]
; CHECK-ELF-NEXT:    ldrsb x0, [x8]
; CHECK-ELF-NEXT:    ret
  %res = load i8, i8* @D, align 4
  %sextres = sext i8 %res to i64
  ret i64 %sextres
}

@E = common global i16 0, align 4

; LDRH does not support loading from a literal.
; Make sure we emit AdrpLdrGot and not AdrpLdrGotLdr for those.
; CHECK-LABEL: _getE
; CHECK: [[ADRP_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: adrp [[ADRP_REG:x[0-9]+]], _E@GOTPAGE
; CHECK-NEXT: [[LDRGOT_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: ldr {{[xw]}}[[LDRGOT_REG:[0-9]+]], [[[ADRP_REG]], _E@GOTPAGEOFF]
; CHECK-NEXT: ldrh w0, [x[[LDRGOT_REG]]]
; CHECK-NEXT: ret
; CHECK: .loh AdrpLdrGot [[ADRP_LABEL]], [[LDRGOT_LABEL]]
define i16 @getE() {
; CHECK-LABEL: getE:
; CHECK:       ; %bb.0:
; CHECK-NEXT:  Lloh39:
; CHECK-NEXT:    adrp x8, _E@GOTPAGE
; CHECK-NEXT:  Lloh40:
; CHECK-NEXT:    ldr x8, [x8, _E@GOTPAGEOFF]
; CHECK-NEXT:    ldrh w0, [x8]
; CHECK-NEXT:    ret
; CHECK-NEXT:    .loh AdrpLdrGot Lloh39, Lloh40
;
; CHECK-ELF-LABEL: getE:
; CHECK-ELF:       // %bb.0:
; CHECK-ELF-NEXT:    adrp x8, :got:E
; CHECK-ELF-NEXT:    ldr x8, [x8, :got_lo12:E]
; CHECK-ELF-NEXT:    ldrh w0, [x8]
; CHECK-ELF-NEXT:    ret
  %res = load i16, i16* @E, align 4
  ret i16 %res
}

; LDRSH supports loading from a literal.
; Make sure we emit AdrpLdrGotLdr for those.
; CHECK-LABEL: _getSExtE
; CHECK: [[ADRP_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: adrp [[ADRP_REG:x[0-9]+]], _E@GOTPAGE
; CHECK-NEXT: [[LDRGOT_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: ldr {{[xw]}}[[LDRGOT_REG:[0-9]+]], [[[ADRP_REG]], _E@GOTPAGEOFF]
; CHECK-NEXT: [[LDR_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: ldrsh w0, [x[[LDRGOT_REG]]]
; CHECK-NEXT: ret
; CHECK: .loh AdrpLdrGotLdr [[ADRP_LABEL]], [[LDRGOT_LABEL]], [[LDR_LABEL]]
define i32 @getSExtE() {
; CHECK-LABEL: getSExtE:
; CHECK:       ; %bb.0:
; CHECK-NEXT:  Lloh41:
; CHECK-NEXT:    adrp x8, _E@GOTPAGE
; CHECK-NEXT:  Lloh42:
; CHECK-NEXT:    ldr x8, [x8, _E@GOTPAGEOFF]
; CHECK-NEXT:  Lloh43:
; CHECK-NEXT:    ldrsh w0, [x8]
; CHECK-NEXT:    ret
; CHECK-NEXT:    .loh AdrpLdrGotLdr Lloh41, Lloh42, Lloh43
;
; CHECK-ELF-LABEL: getSExtE:
; CHECK-ELF:       // %bb.0:
; CHECK-ELF-NEXT:    adrp x8, :got:E
; CHECK-ELF-NEXT:    ldr x8, [x8, :got_lo12:E]
; CHECK-ELF-NEXT:    ldrsh w0, [x8]
; CHECK-ELF-NEXT:    ret
  %res = load i16, i16* @E, align 4
  %sextres = sext i16 %res to i32
  ret i32 %sextres
}

; CHECK-LABEL: _setE
; CHECK: [[ADRP_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: adrp [[ADRP_REG:x[0-9]+]], _E@GOTPAGE
; CHECK-NEXT: [[LDRGOT_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: ldr {{[xw]}}[[LDRGOT_REG:[0-9]+]], [[[ADRP_REG]], _E@GOTPAGEOFF]
; CHECK-NEXT: [[STR_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: strh w0, [x[[LDRGOT_REG]]]
; CHECK-NEXT: ret
; CHECK: .loh AdrpLdrGotStr [[ADRP_LABEL]], [[LDRGOT_LABEL]], [[STR_LABEL]]
define void @setE(i16 %t) {
; CHECK-LABEL: setE:
; CHECK:       ; %bb.0:
; CHECK-NEXT:  Lloh44:
; CHECK-NEXT:    adrp x8, _E@GOTPAGE
; CHECK-NEXT:  Lloh45:
; CHECK-NEXT:    ldr x8, [x8, _E@GOTPAGEOFF]
; CHECK-NEXT:  Lloh46:
; CHECK-NEXT:    strh w0, [x8]
; CHECK-NEXT:    ret
; CHECK-NEXT:    .loh AdrpLdrGotStr Lloh44, Lloh45, Lloh46
;
; CHECK-ELF-LABEL: setE:
; CHECK-ELF:       // %bb.0:
; CHECK-ELF-NEXT:    adrp x8, :got:E
; CHECK-ELF-NEXT:    ldr x8, [x8, :got_lo12:E]
; CHECK-ELF-NEXT:    strh w0, [x8]
; CHECK-ELF-NEXT:    ret
  store i16 %t, i16* @E, align 4
  ret void
}

; LDRSH supports loading from a literal.
; Make sure we emit AdrpLdrGotLdr for those.
; CHECK-LABEL: _getSExt64E
; CHECK: [[ADRP_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: adrp [[ADRP_REG:x[0-9]+]], _E@GOTPAGE
; CHECK-NEXT: [[LDRGOT_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: ldr {{[xw]}}[[LDRGOT_REG:[0-9]+]], [[[ADRP_REG]], _E@GOTPAGEOFF]
; CHECK-NEXT: [[LDR_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: ldrsh x0, [x[[LDRGOT_REG]]]
; CHECK-NEXT: ret
; CHECK: .loh AdrpLdrGotLdr [[ADRP_LABEL]], [[LDRGOT_LABEL]], [[LDR_LABEL]]
define i64 @getSExt64E() {
; CHECK-LABEL: getSExt64E:
; CHECK:       ; %bb.0:
; CHECK-NEXT:  Lloh47:
; CHECK-NEXT:    adrp x8, _E@GOTPAGE
; CHECK-NEXT:  Lloh48:
; CHECK-NEXT:    ldr x8, [x8, _E@GOTPAGEOFF]
; CHECK-NEXT:  Lloh49:
; CHECK-NEXT:    ldrsh x0, [x8]
; CHECK-NEXT:    ret
; CHECK-NEXT:    .loh AdrpLdrGotLdr Lloh47, Lloh48, Lloh49
;
; CHECK-ELF-LABEL: getSExt64E:
; CHECK-ELF:       // %bb.0:
; CHECK-ELF-NEXT:    adrp x8, :got:E
; CHECK-ELF-NEXT:    ldr x8, [x8, :got_lo12:E]
; CHECK-ELF-NEXT:    ldrsh x0, [x8]
; CHECK-ELF-NEXT:    ret
  %res = load i16, i16* @E, align 4
  %sextres = sext i16 %res to i64
  ret i64 %sextres
}

@F = common global i64 0, align 4

; LDR supports loading from a literal.
; Make sure we emit AdrpLdrGotLdr for those.
; CHECK-LABEL: _getF
; CHECK: [[ADRP_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: adrp [[ADRP_REG:x[0-9]+]], _F@GOTPAGE
; CHECK-NEXT: [[LDRGOT_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: ldr {{[xw]}}[[LDRGOT_REG:[0-9]+]], [[[ADRP_REG]], _F@GOTPAGEOFF]
; CHECK-NEXT: [[LDR_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: ldr x0, [x[[LDRGOT_REG]]]
; CHECK-NEXT: ret
; CHECK: .loh AdrpLdrGotLdr [[ADRP_LABEL]], [[LDRGOT_LABEL]], [[LDR_LABEL]]
define i64 @getF() {
; CHECK-LABEL: getF:
; CHECK:       ; %bb.0:
; CHECK-NEXT:  Lloh50:
; CHECK-NEXT:    adrp x8, _F@GOTPAGE
; CHECK-NEXT:  Lloh51:
; CHECK-NEXT:    ldr x8, [x8, _F@GOTPAGEOFF]
; CHECK-NEXT:  Lloh52:
; CHECK-NEXT:    ldr x0, [x8]
; CHECK-NEXT:    ret
; CHECK-NEXT:    .loh AdrpLdrGotLdr Lloh50, Lloh51, Lloh52
;
; CHECK-ELF-LABEL: getF:
; CHECK-ELF:       // %bb.0:
; CHECK-ELF-NEXT:    adrp x8, :got:F
; CHECK-ELF-NEXT:    ldr x8, [x8, :got_lo12:F]
; CHECK-ELF-NEXT:    ldr x0, [x8]
; CHECK-ELF-NEXT:    ret
  %res = load i64, i64* @F, align 4
  ret i64 %res
}

; CHECK-LABEL: _setF
; CHECK: [[ADRP_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: adrp [[ADRP_REG:x[0-9]+]], _F@GOTPAGE
; CHECK-NEXT: [[LDRGOT_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: ldr {{[xw]}}[[LDRGOT_REG:[0-9]+]], [[[ADRP_REG]], _F@GOTPAGEOFF]
; CHECK-NEXT: [[STR_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: str x0, [x[[LDRGOT_REG]]]
; CHECK-NEXT: ret
; CHECK: .loh AdrpLdrGotStr [[ADRP_LABEL]], [[LDRGOT_LABEL]], [[STR_LABEL]]
define void @setF(i64 %t) {
; CHECK-LABEL: setF:
; CHECK:       ; %bb.0:
; CHECK-NEXT:  Lloh53:
; CHECK-NEXT:    adrp x8, _F@GOTPAGE
; CHECK-NEXT:  Lloh54:
; CHECK-NEXT:    ldr x8, [x8, _F@GOTPAGEOFF]
; CHECK-NEXT:  Lloh55:
; CHECK-NEXT:    str x0, [x8]
; CHECK-NEXT:    ret
; CHECK-NEXT:    .loh AdrpLdrGotStr Lloh53, Lloh54, Lloh55
;
; CHECK-ELF-LABEL: setF:
; CHECK-ELF:       // %bb.0:
; CHECK-ELF-NEXT:    adrp x8, :got:F
; CHECK-ELF-NEXT:    ldr x8, [x8, :got_lo12:F]
; CHECK-ELF-NEXT:    str x0, [x8]
; CHECK-ELF-NEXT:    ret
  store i64 %t, i64* @F, align 4
  ret void
}

@G = common global float 0.0, align 4

; LDR float supports loading from a literal.
; Make sure we emit AdrpLdrGotLdr for those.
; CHECK-LABEL: _getG
; CHECK: [[ADRP_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: adrp [[ADRP_REG:x[0-9]+]], _G@GOTPAGE
; CHECK-NEXT: [[LDRGOT_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: ldr {{[xw]}}[[LDRGOT_REG:[0-9]+]], [[[ADRP_REG]], _G@GOTPAGEOFF]
; CHECK-NEXT: [[LDR_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: ldr s0, [x[[LDRGOT_REG]]]
; CHECK-NEXT: ret
; CHECK: .loh AdrpLdrGotLdr [[ADRP_LABEL]], [[LDRGOT_LABEL]], [[LDR_LABEL]]
define float @getG() {
; CHECK-LABEL: getG:
; CHECK:       ; %bb.0:
; CHECK-NEXT:  Lloh56:
; CHECK-NEXT:    adrp x8, _G@GOTPAGE
; CHECK-NEXT:  Lloh57:
; CHECK-NEXT:    ldr x8, [x8, _G@GOTPAGEOFF]
; CHECK-NEXT:  Lloh58:
; CHECK-NEXT:    ldr s0, [x8]
; CHECK-NEXT:    ret
; CHECK-NEXT:    .loh AdrpLdrGotLdr Lloh56, Lloh57, Lloh58
;
; CHECK-ELF-LABEL: getG:
; CHECK-ELF:       // %bb.0:
; CHECK-ELF-NEXT:    adrp x8, :got:G
; CHECK-ELF-NEXT:    ldr x8, [x8, :got_lo12:G]
; CHECK-ELF-NEXT:    ldr s0, [x8]
; CHECK-ELF-NEXT:    ret
  %res = load float, float* @G, align 4
  ret float %res
}

; CHECK-LABEL: _setG
; CHECK: [[ADRP_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: adrp [[ADRP_REG:x[0-9]+]], _G@GOTPAGE
; CHECK-NEXT: [[LDRGOT_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: ldr {{[xw]}}[[LDRGOT_REG:[0-9]+]], [[[ADRP_REG]], _G@GOTPAGEOFF]
; CHECK-NEXT: [[STR_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: str s0, [x[[LDRGOT_REG]]]
; CHECK-NEXT: ret
; CHECK: .loh AdrpLdrGotStr [[ADRP_LABEL]], [[LDRGOT_LABEL]], [[STR_LABEL]]
define void @setG(float %t) {
; CHECK-LABEL: setG:
; CHECK:       ; %bb.0:
; CHECK-NEXT:  Lloh59:
; CHECK-NEXT:    adrp x8, _G@GOTPAGE
; CHECK-NEXT:  Lloh60:
; CHECK-NEXT:    ldr x8, [x8, _G@GOTPAGEOFF]
; CHECK-NEXT:  Lloh61:
; CHECK-NEXT:    str s0, [x8]
; CHECK-NEXT:    ret
; CHECK-NEXT:    .loh AdrpLdrGotStr Lloh59, Lloh60, Lloh61
;
; CHECK-ELF-LABEL: setG:
; CHECK-ELF:       // %bb.0:
; CHECK-ELF-NEXT:    adrp x8, :got:G
; CHECK-ELF-NEXT:    ldr x8, [x8, :got_lo12:G]
; CHECK-ELF-NEXT:    str s0, [x8]
; CHECK-ELF-NEXT:    ret
  store float %t, float* @G, align 4
  ret void
}

@H = common global half 0.0, align 4

; LDR half supports loading from a literal.
; Make sure we emit AdrpLdrGotLdr for those.
; CHECK-LABEL: _getH
; CHECK: [[ADRP_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: adrp [[ADRP_REG:x[0-9]+]], _H@GOTPAGE
; CHECK-NEXT: [[LDRGOT_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: ldr {{[xw]}}[[LDRGOT_REG:[0-9]+]], [[[ADRP_REG]], _H@GOTPAGEOFF]
; CHECK-NEXT: [[LDR_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: ldr h0, [x[[LDRGOT_REG]]]
; CHECK-NEXT: ret
; CHECK: .loh AdrpLdrGotLdr [[ADRP_LABEL]], [[LDRGOT_LABEL]], [[LDR_LABEL]]
define half @getH() {
; CHECK-LABEL: getH:
; CHECK:       ; %bb.0:
; CHECK-NEXT:  Lloh62:
; CHECK-NEXT:    adrp x8, _H@GOTPAGE
; CHECK-NEXT:  Lloh63:
; CHECK-NEXT:    ldr x8, [x8, _H@GOTPAGEOFF]
; CHECK-NEXT:  Lloh64:
; CHECK-NEXT:    ldr h0, [x8]
; CHECK-NEXT:    ret
; CHECK-NEXT:    .loh AdrpLdrGotLdr Lloh62, Lloh63, Lloh64
;
; CHECK-ELF-LABEL: getH:
; CHECK-ELF:       // %bb.0:
; CHECK-ELF-NEXT:    adrp x8, :got:H
; CHECK-ELF-NEXT:    ldr x8, [x8, :got_lo12:H]
; CHECK-ELF-NEXT:    ldr h0, [x8]
; CHECK-ELF-NEXT:    ret
  %res = load half, half* @H, align 4
  ret half %res
}

; CHECK-LABEL: _setH
; CHECK: [[ADRP_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: adrp [[ADRP_REG:x[0-9]+]], _H@GOTPAGE
; CHECK-NEXT: [[LDRGOT_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: ldr {{[xw]}}[[LDRGOT_REG:[0-9]+]], [[[ADRP_REG]], _H@GOTPAGEOFF]
; CHECK-NEXT: [[STR_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: str h0, [x[[LDRGOT_REG]]]
; CHECK-NEXT: ret
; CHECK: .loh AdrpLdrGotStr [[ADRP_LABEL]], [[LDRGOT_LABEL]], [[STR_LABEL]]
define void @setH(half %t) {
; CHECK-LABEL: setH:
; CHECK:       ; %bb.0:
; CHECK-NEXT:  Lloh65:
; CHECK-NEXT:    adrp x8, _H@GOTPAGE
; CHECK-NEXT:  Lloh66:
; CHECK-NEXT:    ldr x8, [x8, _H@GOTPAGEOFF]
; CHECK-NEXT:  Lloh67:
; CHECK-NEXT:    str h0, [x8]
; CHECK-NEXT:    ret
; CHECK-NEXT:    .loh AdrpLdrGotStr Lloh65, Lloh66, Lloh67
;
; CHECK-ELF-LABEL: setH:
; CHECK-ELF:       // %bb.0:
; CHECK-ELF-NEXT:    adrp x8, :got:H
; CHECK-ELF-NEXT:    ldr x8, [x8, :got_lo12:H]
; CHECK-ELF-NEXT:    str h0, [x8]
; CHECK-ELF-NEXT:    ret
  store half %t, half* @H, align 4
  ret void
}

@I = common global double 0.0, align 4

; LDR double supports loading from a literal.
; Make sure we emit AdrpLdrGotLdr for those.
; CHECK-LABEL: _getI
; CHECK: [[ADRP_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: adrp [[ADRP_REG:x[0-9]+]], _I@GOTPAGE
; CHECK-NEXT: [[LDRGOT_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: ldr {{[xw]}}[[LDRGOT_REG:[0-9]+]], [[[ADRP_REG]], _I@GOTPAGEOFF]
; CHECK-NEXT: [[LDR_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: ldr d0, [x[[LDRGOT_REG]]]
; CHECK-NEXT: ret
; CHECK: .loh AdrpLdrGotLdr [[ADRP_LABEL]], [[LDRGOT_LABEL]], [[LDR_LABEL]]
define double @getI() {
; CHECK-LABEL: getI:
; CHECK:       ; %bb.0:
; CHECK-NEXT:  Lloh68:
; CHECK-NEXT:    adrp x8, _I@GOTPAGE
; CHECK-NEXT:  Lloh69:
; CHECK-NEXT:    ldr x8, [x8, _I@GOTPAGEOFF]
; CHECK-NEXT:  Lloh70:
; CHECK-NEXT:    ldr d0, [x8]
; CHECK-NEXT:    ret
; CHECK-NEXT:    .loh AdrpLdrGotLdr Lloh68, Lloh69, Lloh70
;
; CHECK-ELF-LABEL: getI:
; CHECK-ELF:       // %bb.0:
; CHECK-ELF-NEXT:    adrp x8, :got:I
; CHECK-ELF-NEXT:    ldr x8, [x8, :got_lo12:I]
; CHECK-ELF-NEXT:    ldr d0, [x8]
; CHECK-ELF-NEXT:    ret
  %res = load double, double* @I, align 4
  ret double %res
}

; CHECK-LABEL: _setI
; CHECK: [[ADRP_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: adrp [[ADRP_REG:x[0-9]+]], _I@GOTPAGE
; CHECK-NEXT: [[LDRGOT_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: ldr {{[xw]}}[[LDRGOT_REG:[0-9]+]], [[[ADRP_REG]], _I@GOTPAGEOFF]
; CHECK-NEXT: [[STR_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: str d0, [x[[LDRGOT_REG]]]
; CHECK-NEXT: ret
; CHECK: .loh AdrpLdrGotStr [[ADRP_LABEL]], [[LDRGOT_LABEL]], [[STR_LABEL]]
define void @setI(double %t) {
; CHECK-LABEL: setI:
; CHECK:       ; %bb.0:
; CHECK-NEXT:  Lloh71:
; CHECK-NEXT:    adrp x8, _I@GOTPAGE
; CHECK-NEXT:  Lloh72:
; CHECK-NEXT:    ldr x8, [x8, _I@GOTPAGEOFF]
; CHECK-NEXT:  Lloh73:
; CHECK-NEXT:    str d0, [x8]
; CHECK-NEXT:    ret
; CHECK-NEXT:    .loh AdrpLdrGotStr Lloh71, Lloh72, Lloh73
;
; CHECK-ELF-LABEL: setI:
; CHECK-ELF:       // %bb.0:
; CHECK-ELF-NEXT:    adrp x8, :got:I
; CHECK-ELF-NEXT:    ldr x8, [x8, :got_lo12:I]
; CHECK-ELF-NEXT:    str d0, [x8]
; CHECK-ELF-NEXT:    ret
  store double %t, double* @I, align 4
  ret void
}

@J = common global <2 x i32> <i32 0, i32 0>, align 4

; LDR 64-bit vector supports loading from a literal.
; Make sure we emit AdrpLdrGotLdr for those.
; CHECK-LABEL: _getJ
; CHECK: [[ADRP_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: adrp [[ADRP_REG:x[0-9]+]], _J@GOTPAGE
; CHECK-NEXT: [[LDRGOT_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: ldr {{[xw]}}[[LDRGOT_REG:[0-9]+]], [[[ADRP_REG]], _J@GOTPAGEOFF]
; CHECK-NEXT: [[LDR_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: ldr d0, [x[[LDRGOT_REG]]]
; CHECK-NEXT: ret
; CHECK: .loh AdrpLdrGotLdr [[ADRP_LABEL]], [[LDRGOT_LABEL]], [[LDR_LABEL]]
define <2 x i32> @getJ() {
; CHECK-LABEL: getJ:
; CHECK:       ; %bb.0:
; CHECK-NEXT:  Lloh74:
; CHECK-NEXT:    adrp x8, _J@GOTPAGE
; CHECK-NEXT:  Lloh75:
; CHECK-NEXT:    ldr x8, [x8, _J@GOTPAGEOFF]
; CHECK-NEXT:  Lloh76:
; CHECK-NEXT:    ldr d0, [x8]
; CHECK-NEXT:    ret
; CHECK-NEXT:    .loh AdrpLdrGotLdr Lloh74, Lloh75, Lloh76
;
; CHECK-ELF-LABEL: getJ:
; CHECK-ELF:       // %bb.0:
; CHECK-ELF-NEXT:    adrp x8, :got:J
; CHECK-ELF-NEXT:    ldr x8, [x8, :got_lo12:J]
; CHECK-ELF-NEXT:    ldr d0, [x8]
; CHECK-ELF-NEXT:    ret
  %res = load <2 x i32>, <2 x i32>* @J, align 4
  ret <2 x i32> %res
}

; CHECK-LABEL: _setJ
; CHECK: [[ADRP_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: adrp [[ADRP_REG:x[0-9]+]], _J@GOTPAGE
; CHECK-NEXT: [[LDRGOT_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: ldr {{[xw]}}[[LDRGOT_REG:[0-9]+]], [[[ADRP_REG]], _J@GOTPAGEOFF]
; CHECK-NEXT: [[STR_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: str d0, [x[[LDRGOT_REG]]]
; CHECK-NEXT: ret
; CHECK: .loh AdrpLdrGotStr [[ADRP_LABEL]], [[LDRGOT_LABEL]], [[STR_LABEL]]
define void @setJ(<2 x i32> %t) {
; CHECK-LABEL: setJ:
; CHECK:       ; %bb.0:
; CHECK-NEXT:  Lloh77:
; CHECK-NEXT:    adrp x8, _J@GOTPAGE
; CHECK-NEXT:  Lloh78:
; CHECK-NEXT:    ldr x8, [x8, _J@GOTPAGEOFF]
; CHECK-NEXT:  Lloh79:
; CHECK-NEXT:    str d0, [x8]
; CHECK-NEXT:    ret
; CHECK-NEXT:    .loh AdrpLdrGotStr Lloh77, Lloh78, Lloh79
;
; CHECK-ELF-LABEL: setJ:
; CHECK-ELF:       // %bb.0:
; CHECK-ELF-NEXT:    adrp x8, :got:J
; CHECK-ELF-NEXT:    ldr x8, [x8, :got_lo12:J]
; CHECK-ELF-NEXT:    str d0, [x8]
; CHECK-ELF-NEXT:    ret
  store <2 x i32> %t, <2 x i32>* @J, align 4
  ret void
}

@K = common global <4 x i32> <i32 0, i32 0, i32 0, i32 0>, align 4

; LDR 128-bit vector supports loading from a literal.
; Make sure we emit AdrpLdrGotLdr for those.
; CHECK-LABEL: _getK
; CHECK: [[ADRP_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: adrp [[ADRP_REG:x[0-9]+]], _K@GOTPAGE
; CHECK-NEXT: [[LDRGOT_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: ldr {{[xw]}}[[LDRGOT_REG:[0-9]+]], [[[ADRP_REG]], _K@GOTPAGEOFF]
; CHECK-NEXT: [[LDR_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: ldr q0, [x[[LDRGOT_REG]]]
; CHECK-NEXT: ret
; CHECK: .loh AdrpLdrGotLdr [[ADRP_LABEL]], [[LDRGOT_LABEL]], [[LDR_LABEL]]
define <4 x i32> @getK() {
; CHECK-LABEL: getK:
; CHECK:       ; %bb.0:
; CHECK-NEXT:  Lloh80:
; CHECK-NEXT:    adrp x8, _K@GOTPAGE
; CHECK-NEXT:  Lloh81:
; CHECK-NEXT:    ldr x8, [x8, _K@GOTPAGEOFF]
; CHECK-NEXT:  Lloh82:
; CHECK-NEXT:    ldr q0, [x8]
; CHECK-NEXT:    ret
; CHECK-NEXT:    .loh AdrpLdrGotLdr Lloh80, Lloh81, Lloh82
;
; CHECK-ELF-LABEL: getK:
; CHECK-ELF:       // %bb.0:
; CHECK-ELF-NEXT:    adrp x8, :got:K
; CHECK-ELF-NEXT:    ldr x8, [x8, :got_lo12:K]
; CHECK-ELF-NEXT:    ldr q0, [x8]
; CHECK-ELF-NEXT:    ret
  %res = load <4 x i32>, <4 x i32>* @K, align 4
  ret <4 x i32> %res
}

; CHECK-LABEL: _setK
; CHECK: [[ADRP_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: adrp [[ADRP_REG:x[0-9]+]], _K@GOTPAGE
; CHECK-NEXT: [[LDRGOT_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: ldr {{[xw]}}[[LDRGOT_REG:[0-9]+]], [[[ADRP_REG]], _K@GOTPAGEOFF]
; CHECK-NEXT: [[STR_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: str q0, [x[[LDRGOT_REG]]]
; CHECK-NEXT: ret
; CHECK: .loh AdrpLdrGotStr [[ADRP_LABEL]], [[LDRGOT_LABEL]], [[STR_LABEL]]
define void @setK(<4 x i32> %t) {
; CHECK-LABEL: setK:
; CHECK:       ; %bb.0:
; CHECK-NEXT:  Lloh83:
; CHECK-NEXT:    adrp x8, _K@GOTPAGE
; CHECK-NEXT:  Lloh84:
; CHECK-NEXT:    ldr x8, [x8, _K@GOTPAGEOFF]
; CHECK-NEXT:  Lloh85:
; CHECK-NEXT:    str q0, [x8]
; CHECK-NEXT:    ret
; CHECK-NEXT:    .loh AdrpLdrGotStr Lloh83, Lloh84, Lloh85
;
; CHECK-ELF-LABEL: setK:
; CHECK-ELF:       // %bb.0:
; CHECK-ELF-NEXT:    adrp x8, :got:K
; CHECK-ELF-NEXT:    ldr x8, [x8, :got_lo12:K]
; CHECK-ELF-NEXT:    str q0, [x8]
; CHECK-ELF-NEXT:    ret
  store <4 x i32> %t, <4 x i32>* @K, align 4
  ret void
}

@L = common global <1 x i8> <i8 0>, align 4

; LDR 8-bit vector supports loading from a literal.
; Make sure we emit AdrpLdrGotLdr for those.
; CHECK-LABEL: _getL
; CHECK: [[ADRP_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: adrp [[ADRP_REG:x[0-9]+]], _L@GOTPAGE
; CHECK-NEXT: [[LDRGOT_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: ldr {{[xw]}}[[LDRGOT_REG:[0-9]+]], [[[ADRP_REG]], _L@GOTPAGEOFF]
; CHECK-NEXT: [[LDR_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: ldr b0, [x[[LDRGOT_REG]]]
; CHECK-NEXT: ret
; CHECK: .loh AdrpLdrGotLdr [[ADRP_LABEL]], [[LDRGOT_LABEL]], [[LDR_LABEL]]
define <1 x i8> @getL() {
; CHECK-LABEL: getL:
; CHECK:       ; %bb.0:
; CHECK-NEXT:  Lloh86:
; CHECK-NEXT:    adrp x8, _L@GOTPAGE
; CHECK-NEXT:  Lloh87:
; CHECK-NEXT:    ldr x8, [x8, _L@GOTPAGEOFF]
; CHECK-NEXT:  Lloh88:
; CHECK-NEXT:    ldr b0, [x8]
; CHECK-NEXT:    ret
; CHECK-NEXT:    .loh AdrpLdrGotLdr Lloh86, Lloh87, Lloh88
;
; CHECK-ELF-LABEL: getL:
; CHECK-ELF:       // %bb.0:
; CHECK-ELF-NEXT:    adrp x8, :got:L
; CHECK-ELF-NEXT:    ldr x8, [x8, :got_lo12:L]
; CHECK-ELF-NEXT:    ldr b0, [x8]
; CHECK-ELF-NEXT:    ret
  %res = load <1 x i8>, <1 x i8>* @L, align 4
  ret <1 x i8> %res
}

; CHECK-LABEL: _setL
; CHECK: [[ADRP_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: adrp [[ADRP_REG:x[0-9]+]], _L@GOTPAGE
; CHECK-NEXT: ; kill
; CHECK-NEXT: [[LDRGOT_LABEL:Lloh[0-9]+]]:
; CHECK-NEXT: ldr {{[xw]}}[[LDRGOT_REG:[0-9]+]], [[[ADRP_REG]], _L@GOTPAGEOFF]
; Ultimately we should generate str b0, but right now, we match the vector
; variant which does not allow to fold the immediate into the store.
; CHECK-NEXT: st1.b { v0 }[0], [x[[LDRGOT_REG]]]
; CHECK-NEXT: ret
; CHECK: .loh AdrpLdrGot [[ADRP_LABEL]], [[LDRGOT_LABEL]]
define void @setL(<1 x i8> %t) {
; CHECK-LABEL: setL:
; CHECK:       ; %bb.0:
; CHECK-NEXT:  Lloh89:
; CHECK-NEXT:    adrp x8, _L@GOTPAGE
; CHECK-NEXT:    ; kill: def $d0 killed $d0 def $q0
; CHECK-NEXT:  Lloh90:
; CHECK-NEXT:    ldr x8, [x8, _L@GOTPAGEOFF]
; CHECK-NEXT:    st1.b { v0 }[0], [x8]
; CHECK-NEXT:    ret
; CHECK-NEXT:    .loh AdrpLdrGot Lloh89, Lloh90
;
; CHECK-ELF-LABEL: setL:
; CHECK-ELF:       // %bb.0:
; CHECK-ELF-NEXT:    adrp x8, :got:L
; CHECK-ELF-NEXT:    // kill: def $d0 killed $d0 def $q0
; CHECK-ELF-NEXT:    ldr x8, [x8, :got_lo12:L]
; CHECK-ELF-NEXT:    st1 { v0.b }[0], [x8]
; CHECK-ELF-NEXT:    ret
  store <1 x i8> %t, <1 x i8>* @L, align 4
  ret void
}

; Make sure we do not assert when we do not track
; all the aliases of a tuple register.
; Indeed the tuple register can be tracked because of
; one of its element, but the other elements of the tuple
; do not need to be tracked and we used to assert on that.
; Note: The test case is fragile in the sense that we need
; a tuple register to appear in the lowering. Thus, the target
; cpu is required to have the problem reproduced.
; CHECK-LABEL: _uninterestingSub
; CHECK: [[LOH_LABEL0:Lloh[0-9]+]]:
; CHECK: adrp [[ADRP_REG:x[0-9]+]], [[CONSTPOOL:lCPI[0-9]+_[0-9]+]]@PAGE
; CHECK: [[LOH_LABEL1:Lloh[0-9]+]]:
; CHECK: ldr q[[IDX:[0-9]+]], [[[ADRP_REG]], [[CONSTPOOL]]@PAGEOFF]
; The tuple comes from the next instruction.
; CHECK: ext.16b v{{[0-9]+}}, v{{[0-9]+}}, v{{[0-9]+}}, #1
; CHECK: ret
; CHECK: .loh AdrpLdr [[LOH_LABEL0]], [[LOH_LABEL1]]
define void @uninterestingSub(i8* nocapture %row) #0 {
; CHECK-LABEL: uninterestingSub:
; CHECK:       ; %bb.0:
; CHECK-NEXT:  Lloh91:
; CHECK-NEXT:    adrp x8, lCPI36_0@PAGE
; CHECK-NEXT:  Lloh92:
; CHECK-NEXT:    ldr q0, [x8, lCPI36_0@PAGEOFF]
; CHECK-NEXT:    ldp q1, q2, [x0]
; CHECK-NEXT:    ext.16b v0, v0, v1, #1
; CHECK-NEXT:    str q0, [x0]
; CHECK-NEXT:    ldr q0, [x8]
; CHECK-NEXT:    ext.16b v0, v2, v0, #1
; CHECK-NEXT:    str q0, [x8]
; CHECK-NEXT:    ret
; CHECK-NEXT:    .loh AdrpLdr Lloh91, Lloh92
;
; CHECK-ELF-LABEL: uninterestingSub:
; CHECK-ELF:       // %bb.0:
; CHECK-ELF-NEXT:    adrp x8, .LCPI36_0
; CHECK-ELF-NEXT:    ldr q0, [x8, :lo12:.LCPI36_0]
; CHECK-ELF-NEXT:    ldp q1, q2, [x0]
; CHECK-ELF-NEXT:    ext v0.16b, v0.16b, v1.16b, #1
; CHECK-ELF-NEXT:    str q0, [x0]
; CHECK-ELF-NEXT:    ldr q0, [x8]
; CHECK-ELF-NEXT:    ext v0.16b, v2.16b, v0.16b, #1
; CHECK-ELF-NEXT:    str q0, [x8]
; CHECK-ELF-NEXT:    ret
  %tmp = bitcast i8* %row to <16 x i8>*
  %tmp1 = load <16 x i8>, <16 x i8>* %tmp, align 16
  %vext43 = shufflevector <16 x i8> <i8 undef, i8 16, i8 15, i8 14, i8 13, i8 12, i8 11, i8 10, i8 9, i8 8, i8 7, i8 6, i8 5, i8 4, i8 3, i8 2>, <16 x i8> %tmp1, <16 x i32> <i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15, i32 16>
  %add.i.414 = add <16 x i8> zeroinitializer, %vext43
  store <16 x i8> %add.i.414, <16 x i8>* %tmp, align 16
  %add.ptr51 = getelementptr inbounds i8, i8* %row, i64 16
  %tmp2 = bitcast i8* %add.ptr51 to <16 x i8>*
  %tmp3 = load <16 x i8>, <16 x i8>* %tmp2, align 16
  %tmp4 = bitcast i8* undef to <16 x i8>*
  %tmp5 = load <16 x i8>, <16 x i8>* %tmp4, align 16
  %vext157 = shufflevector <16 x i8> %tmp3, <16 x i8> %tmp5, <16 x i32> <i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15, i32 16>
  %add.i.402 = add <16 x i8> zeroinitializer, %vext157
  store <16 x i8> %add.i.402, <16 x i8>* %tmp4, align 16
  ret void
}

@.str.89 = external unnamed_addr constant [12 x i8], align 1
@.str.90 = external unnamed_addr constant [5 x i8], align 1
; CHECK-LABEL: test_r274582
define void @test_r274582(double %x) {
; CHECK-LABEL: test_r274582:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    cbnz wzr, LBB37_2
; CHECK-NEXT:  ; %bb.1: ; %if.then.i
; CHECK-NEXT:    ret
; CHECK-NEXT:  LBB37_2: ; %if.end.i
; CHECK-NEXT:    sub sp, sp, #32
; CHECK-NEXT:    stp x29, x30, [sp, #16] ; 16-byte Folded Spill
; CHECK-NEXT:    .cfi_def_cfa_offset 32
; CHECK-NEXT:    .cfi_offset w30, -8
; CHECK-NEXT:    .cfi_offset w29, -16
; CHECK-NEXT:  Lloh93:
; CHECK-NEXT:    adrp x8, lCPI37_0@PAGE
; CHECK-NEXT:  Lloh94:
; CHECK-NEXT:    adrp x0, _.str.89@GOTPAGE
; CHECK-NEXT:  Lloh95:
; CHECK-NEXT:    ldr d1, [x8, lCPI37_0@PAGEOFF]
; CHECK-NEXT:  Lloh96:
; CHECK-NEXT:    adrp x8, _.str.90@GOTPAGE
; CHECK-NEXT:  Lloh97:
; CHECK-NEXT:    ldr x8, [x8, _.str.90@GOTPAGEOFF]
; CHECK-NEXT:  Lloh98:
; CHECK-NEXT:    ldr x0, [x0, _.str.89@GOTPAGEOFF]
; CHECK-NEXT:    fmul d0, d0, d1
; CHECK-NEXT:    str x8, [sp]
; CHECK-NEXT:    fadd d0, d0, d0
; CHECK-NEXT:    fsub d0, d0, d0
; CHECK-NEXT:    str d0, [sp, #8]
; CHECK-NEXT:    bl _callee
; CHECK-NEXT:    brk #0x1
; CHECK-NEXT:    .loh AdrpLdrGot Lloh96, Lloh97
; CHECK-NEXT:    .loh AdrpLdrGot Lloh94, Lloh98
; CHECK-NEXT:    .loh AdrpAdrp Lloh93, Lloh96
; CHECK-NEXT:    .loh AdrpLdr Lloh93, Lloh95
;
; CHECK-ELF-LABEL: test_r274582:
; CHECK-ELF:       // %bb.0: // %entry
; CHECK-ELF-NEXT:    cbnz wzr, .LBB37_2
; CHECK-ELF-NEXT:  // %bb.1: // %if.then.i
; CHECK-ELF-NEXT:    ret
; CHECK-ELF-NEXT:  .LBB37_2: // %if.end.i
; CHECK-ELF-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; CHECK-ELF-NEXT:    .cfi_def_cfa_offset 16
; CHECK-ELF-NEXT:    .cfi_offset w30, -16
; CHECK-ELF-NEXT:    adrp x8, .LCPI37_0
; CHECK-ELF-NEXT:    adrp x0, :got:.str.89
; CHECK-ELF-NEXT:    adrp x1, :got:.str.90
; CHECK-ELF-NEXT:    ldr d1, [x8, :lo12:.LCPI37_0]
; CHECK-ELF-NEXT:    ldr x0, [x0, :got_lo12:.str.89]
; CHECK-ELF-NEXT:    ldr x1, [x1, :got_lo12:.str.90]
; CHECK-ELF-NEXT:    fmul d0, d0, d1
; CHECK-ELF-NEXT:    fadd d0, d0, d0
; CHECK-ELF-NEXT:    fsub d0, d0, d0
; CHECK-ELF-NEXT:    bl callee
entry:
  br i1 undef, label %if.then.i, label %if.end.i
if.then.i:
  ret void
if.end.i:
  %mul = fmul double %x, 1.000000e-06
  %add = fadd double %mul, %mul
  %sub = fsub double %add, %add
  call void (i8*, ...) @callee(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.89, i64 0, i64 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.90, i64 0, i64 0), double %sub)
  unreachable
}
declare void @callee(i8* nocapture readonly, ...)

attributes #0 = { "target-cpu"="cyclone" }
