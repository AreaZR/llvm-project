; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 4
; RUN: llc -mtriple=aarch64 -mattr=+v8.9a --global-isel=0 < %s | FileCheck %s
; RUN: llc -mtriple=aarch64 -mattr=+v8.9a --global-isel=1 --global-isel-abort=1 < %s | FileCheck %s

@a = internal global ptr null, align 8
@b = external global ptr, align 8

define void @test(ptr %i, i32 %j) nounwind ssp {
entry:
  %j.addr = alloca i32, align 4
  store i32 %j, ptr %j.addr, align 4, !tbaa !0
  %tmp = bitcast ptr %j.addr to ptr

  %i.next = getelementptr i8, ptr %i, i64 2

  ; Verify prefetching works for all the different kinds of pointers we might
  ; want to prefetch.

  call void @llvm.aarch64.prefetch(ptr null, i32 0, i32 0, i32 0, i32 1)

  call void @llvm.aarch64.prefetch(ptr %tmp, i32 0, i32 0, i32 0, i32 1)

  call void @llvm.aarch64.prefetch(ptr %i, i32 0, i32 0, i32 0, i32 1)

  call void @llvm.aarch64.prefetch(ptr %i.next, i32 0, i32 0, i32 0, i32 1)

  call void @llvm.aarch64.prefetch(ptr @a, i32 0, i32 0, i32 0, i32 1)

  call void @llvm.aarch64.prefetch(ptr @b, i32 0, i32 0, i32 0, i32 1)

  ; Verify that we can generate every single valid prefetch value.

  call void @llvm.aarch64.prefetch(ptr null, i32 1, i32 0, i32 0, i32 1)

  call void @llvm.aarch64.prefetch(ptr null, i32 0, i32 1, i32 0, i32 1)

  call void @llvm.aarch64.prefetch(ptr null, i32 0, i32 2, i32 0, i32 1)

  call void @llvm.aarch64.prefetch(ptr null, i32 0, i32 3, i32 0, i32 1)

  call void @llvm.aarch64.prefetch(ptr null, i32 0, i32 0, i32 1, i32 1)

  call void @llvm.aarch64.prefetch(ptr null, i32 0, i32 0, i32 0, i32 0)

  ret void
}

declare void @llvm.aarch64.prefetch(ptr readonly, i32 immarg, i32 immarg, i32 immarg, i32 immarg) #0

attributes #0 = { inaccessiblemem_or_argmemonly nounwind willreturn }

!0 = !{!"int", !1}
!1 = !{!"omnipotent char", !2}
!2 = !{!"Simple C/C++ TBAA"}
!3 = !{!"any pointer", !1}
;; NOTE: These prefixes are unused and the list is autogenerated. Do not add tests below this line:
; CHECK: {{.*}}
