; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 4
; RUN: llc < %s | FileCheck %s

; Vararg saving must save Q registers using the equivalent of STR/STP.

target datalayout = "E-m:e-i64:64-i128:128-n32:64-S128"
target triple = "aarch64_be"

%struct.__va_list = type { ptr, ptr, ptr, i32, i32 }

declare void @llvm.va_start(ptr) nounwind
declare void @llvm.va_end(ptr) nounwind

define double @callee(i32 %a, ...) {
; CHECK-LABEL: callee:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    sub sp, sp, #224
; CHECK-NEXT:    .cfi_def_cfa_offset 224
; CHECK-NEXT:    mov x8, #-128 // =0xffffffffffffff80
; CHECK-NEXT:    mov x9, sp
; CHECK-NEXT:    add x10, sp, #136
; CHECK-NEXT:    movk x8, #65480, lsl #32
; CHECK-NEXT:    add x9, x9, #128
; CHECK-NEXT:    stp x1, x2, [sp, #136]
; CHECK-NEXT:    stp x9, x8, [sp, #208]
; CHECK-NEXT:    add x9, x10, #56
; CHECK-NEXT:    add x10, sp, #224
; CHECK-NEXT:    mov x8, #-128 // =0xffffffffffffff80
; CHECK-NEXT:    stp x3, x4, [sp, #152]
; CHECK-NEXT:    stp x5, x6, [sp, #168]
; CHECK-NEXT:    stp q0, q1, [sp]
; CHECK-NEXT:    stp q2, q3, [sp, #32]
; CHECK-NEXT:    stp q4, q5, [sp, #64]
; CHECK-NEXT:    stp q6, q7, [sp, #96]
; CHECK-NEXT:    str x9, [sp, #200]
; CHECK-NEXT:    stp x7, x10, [sp, #184]
; CHECK-NEXT:    tbz w8, #31, .LBB0_2
; CHECK-NEXT:  // %bb.1: // %vaarg.maybe_reg
; CHECK-NEXT:    add w9, w8, #16
; CHECK-NEXT:    cmp w9, #0
; CHECK-NEXT:    str w9, [sp, #220]
; CHECK-NEXT:    b.le .LBB0_4
; CHECK-NEXT:  .LBB0_2: // %vaarg.on_stack
; CHECK-NEXT:    ldr x8, [sp, #192]
; CHECK-NEXT:    add x9, x8, #8
; CHECK-NEXT:    str x9, [sp, #192]
; CHECK-NEXT:  .LBB0_3: // %vaarg.end
; CHECK-NEXT:    ldr d0, [x8]
; CHECK-NEXT:    add sp, sp, #224
; CHECK-NEXT:    ret
; CHECK-NEXT:  .LBB0_4: // %vaarg.in_reg
; CHECK-NEXT:    ldr x9, [sp, #208]
; CHECK-NEXT:    add x8, x9, x8
; CHECK-NEXT:    add x8, x8, #8
; CHECK-NEXT:    b .LBB0_3
entry:
  %vl = alloca %struct.__va_list, align 8
  call void @llvm.va_start(ptr %vl)
  %vr_offs_p = getelementptr inbounds %struct.__va_list, ptr %vl, i64 0, i32 4
  %vr_offs = load i32, ptr %vr_offs_p, align 4
  %0 = icmp sgt i32 %vr_offs, -1
  br i1 %0, label %vaarg.on_stack, label %vaarg.maybe_reg

vaarg.maybe_reg:                                  ; preds = %entry
  %new_reg_offs = add i32 %vr_offs, 16
  store i32 %new_reg_offs, ptr %vr_offs_p, align 4
  %inreg = icmp slt i32 %new_reg_offs, 1
  br i1 %inreg, label %vaarg.in_reg, label %vaarg.on_stack

vaarg.in_reg:                                     ; preds = %vaarg.maybe_reg
  %reg_top_p = getelementptr inbounds %struct.__va_list, ptr %vl, i64 0, i32 2
  %reg_top = load ptr, ptr %reg_top_p, align 8
  %1 = sext i32 %vr_offs to i64
  %2 = getelementptr i8, ptr %reg_top, i64 %1
  %3 = ptrtoint ptr %2 to i64
  %align_be = add i64 %3, 8
  %4 = inttoptr i64 %align_be to ptr
  br label %vaarg.end

vaarg.on_stack:                                   ; preds = %vaarg.maybe_reg, %entry
  %stack = load ptr, ptr %vl, align 8
  %new_stack = getelementptr i8, ptr %stack, i64 8
  store ptr %new_stack, ptr %vl, align 8
  br label %vaarg.end

vaarg.end:                                        ; preds = %vaarg.on_stack, %vaarg.in_reg
  %.sink = phi ptr [ %4, %vaarg.in_reg ], [ %stack, %vaarg.on_stack ]
  %5 = load double, ptr %.sink, align 8
  call void @llvm.va_end(ptr %vl)
  ret double %5
}
